<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="浮生若梦个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>使用RKE部署一个k8s集群并部署Rancher HA | 浮生若梦</title>
<link rel="shortcut icon" href="/favicon.ico?v=1674058894661">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?2871f22e83c89c6702367a34c06c701d";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>



  <meta name="description" content="使用RKE部署一个k8s集群并部署Rancher HA" />
  <meta name="keywords" content="kubernetes,k8s,docker,持续集成,linux" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>浮生若梦</span>
            </a>  
          
        </div>
        
          <p class="subtitle">醉生梦死</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://blog.muzim.cn" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://blog.muzim.cn/archives" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://blog.muzim.cn/tags" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://blog.muzim.cn/post/about" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://blog.muzim.cn/post/SQsxz7MCp" target="_self">
                  <i class="fa fa-globe"></i> 命令速查
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_blank">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">浮生若梦</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>浮生若梦，为欢几何</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://blog.muzim.cn/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/lm93129">
              <i class="fa fa-github" title="GITHUB"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%AE%89%E8%A3%85rke">安装RKE</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4">部署k8s集群</a>
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">生成集群配置文件</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2">开始部署</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2helm">部署Helm</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAhelm%E6%9D%83%E9%99%90">创建helm权限</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96helm">初始化helm</a>
<ul>
<li><a href="#%E6%9B%B4%E6%96%B0helm">更新helm</a></li>
</ul>
</li>
<li><a href="#%E6%B7%BB%E5%8A%A0rancher%E7%9A%84charts">添加rancher的charts</a></li>
<li><a href="#%E5%AE%89%E8%A3%85rancher">安装rancher</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8nginx%E7%9A%84%E9%85%8D%E7%BD%AE">外部负载均衡器nginx的配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://blog.muzim.cn/post/PmaL-uIiQ/"> 使用RKE部署一个k8s集群并部署Rancher HA </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2019-12-27 09:33:03">2019-12-27</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://blog.muzim.cn/tag/QNC8T5st1/"> <span>kubernetes</span> </a>、   
      <a href="https://blog.muzim.cn/tag/rkQFlt07z/"> <span>k8s</span> </a>、   
      <a href="https://blog.muzim.cn/tag/XTf6QFya9/"> <span>docker</span> </a>、   
      <a href="https://blog.muzim.cn/tag/R5Ken2nRw/"> <span>持续集成</span> </a>、   
      <a href="https://blog.muzim.cn/tag/-lhVZc40P/">
        <span>linux</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >12<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >2584<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p><ul class="markdownIt-TOC">
<li><a href="#%E5%AE%89%E8%A3%85rke">安装RKE</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4">部署k8s集群</a>
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">生成集群配置文件</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2">开始部署</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2helm">部署Helm</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAhelm%E6%9D%83%E9%99%90">创建helm权限</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96helm">初始化helm</a>
<ul>
<li><a href="#%E6%9B%B4%E6%96%B0helm">更新helm</a></li>
</ul>
</li>
<li><a href="#%E6%B7%BB%E5%8A%A0rancher%E7%9A%84charts">添加rancher的charts</a></li>
<li><a href="#%E5%AE%89%E8%A3%85rancher">安装rancher</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8nginx%E7%9A%84%E9%85%8D%E7%BD%AE">外部负载均衡器nginx的配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<br>
RKE全称为Rancher Kubernetes Engine，是rancher开源的轻量级k8s集群部署工具，使用他可以快速的部署一个k8s集群</p>
<!-- more -->
<h1 id="安装rke">安装RKE</h1>
<p>首先需要下载RKE这个工具，下载地址为：https://github.com/rancher/rke/releases<br>
根据自己的平台，下载对应的可执行文件，下面我以ubuntu来做演示说明。</p>
<ol>
<li>下载rke_linux_amd64</li>
<li><code>chmod +x rke_linux_amd64</code>赋予可执行权限</li>
<li>改名为rke，<code>mv rke_linux_amd64 rke</code></li>
<li>放入bin目录（可选）</li>
</ol>
<p>以上三步就安装好了RKE，mac可以直接用brew安装，命令为<code>brew install rke</code></p>
<h1 id="部署k8s集群">部署k8s集群</h1>
<h2 id="生成集群配置文件">生成集群配置文件</h2>
<p>安装好了RKE之后，首先生成RKE的配置文件。<br>
使用自带命令<code>rke config</code>，生成<code>cluster.yml</code>配置文件</p>
<p>生成之后默认会有一个示例的配置文件。文件中的controlplane 就是k8s中所说的master。下面来看下这个配置文件(已经经过修改的版本)。<br>
我们以3主3etcd，3work这种经典k8s集群模式来讲解下配置文件改如何写。请仔细阅读，对于部署k8s有以下几点需要注意的。</p>
<ol>
<li>账户不能用root账户</li>
<li>所有节点的时间必须同步</li>
<li>使用的非root账户要能正常使用docker</li>
<li>配置建议再2C4G以上，推荐是4C8G比较合适，磁盘40G</li>
</ol>
<pre><code class="language-yaml">nodes:
  - address: 192.168.1.1
    port: &quot;22&quot; # ssh 端口
    internal_address: &quot;&quot; # 内网IP，如果是公有云的这种有公私网两个IP的，则address配置为公网IP
    role:
      - controlplane  # 控制节点角色，等于k8s的master
      - etcd
    user: ubuntu  # 服务器登陆账户
    hostname_override: master-etcd-01
    docker_socket: /var/run/docker.sock  # docker sock所在路径，如果是用snap安装的dockers需要自行修改
    ssh_key_path: &quot;~/.ssh/id_rsa&quot;  # ssh key的路径，必须是免密登录，不能使用账户密码
    labels: {} # 标签说明
  - address: 192.168.1.2
    port: &quot;22&quot;
    internal_address: &quot;&quot;
    role:
      - controlplane
      - etcd
    user: ubuntu
    hostname_override: master-etcd-02
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
  - address: 192.168.1.3
    port: &quot;22&quot;
    internal_address: &quot;&quot;
    role:
      - controlplane
      - etcd
    user: ubuntu
    hostname_override: master-etcd-03
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
  - address: 192.168.1.4
    port: &quot;22&quot;
    internal_address: &quot;&quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-1
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress  # 标记后只有该标记节点会部署ingress
  - address: 192.168.1.6
    port: &quot;22&quot;
    internal_address: &quot;&quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-2
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress
  - address: 192.168.1.7
    port: &quot;22&quot;
    internal_address: &quot;&quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-3
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress
services:
# ETCD相关配置，另外备份是可以备份到s3的，这个配置见官方文档
  etcd:
    extra_args:
      auto-compaction-retention: 240 #(单位小时)
      # 修改空间配额为$((6*1024*1024*1024))，默认2G,最大8G
      quota-backend-bytes: &quot;6442450944&quot;
    backup_config:
      enabled: true
      interval_hours: 12
      retention: 6
  kube-api:
    service_cluster_ip_range: 10.43.0.0/16
    service_node_port_range: &quot;20000-40000&quot;
    pod_security_policy: false
    always_pull_images: false
# 控制器的一些配置，比如节点判断失联后多久开始迁移等
  kube-controller:
    extra_args:
      ## 当节点通信失败后，再等一段时间kubernetes判定节点为notready状态。
      ## 这个时间段必须是kubelet的nodeStatusUpdateFrequency(默认10s)的整数倍，
      ## 其中N表示允许kubelet同步节点状态的重试次数，默认40s。
      node-monitor-grace-period: &quot;20s&quot;
      ## 再持续通信失败一段时间后，kubernetes判定节点为unhealthy状态，默认1m0s。
      node-startup-grace-period: &quot;30s&quot;
      ## 再持续失联一段时间，kubernetes开始迁移失联节点的Pod，默认5m0s。
      pod-eviction-timeout: &quot;1m&quot;
    cluster_cidr: 10.42.0.0/16
    service_cluster_ip_range: 10.43.0.0/16
# 集群的一些配置，包括资源预留，集群名字，dns等配置
  kubelet:
    extra_args:
      serialize-image-pulls: &quot;false&quot;
      registry-burst: &quot;10&quot;
      registry-qps: &quot;0&quot;
      # # 节点资源预留
      # enforce-node-allocatable: 'pods'
      # system-reserved: 'cpu=0.5,memory=500Mi'
      # kube-reserved: 'cpu=0.5,memory=1500Mi'
      # # POD驱逐，这个参数只支持内存和磁盘。
      # ## 硬驱逐伐值
      # ### 当节点上的可用资源降至保留值以下时，就会触发强制驱逐。强制驱逐会强制kill掉POD，不会等POD自动退出。
      # eviction-hard: 'memory.available&lt;300Mi,nodefs.available&lt;10%,imagefs.available&lt;15%,nodefs.inodesFree&lt;5%'
      # ## 软驱逐伐值
      # ### 以下四个参数配套使用，当节点上的可用资源少于这个值时但大于硬驱逐伐值时候，会等待eviction-soft-grace-period设置的时长；
      # ### 等待中每10s检查一次，当最后一次检查还触发了软驱逐伐值就会开始驱逐，驱逐不会直接Kill POD，先发送停止信号给POD，然后等待eviction-max-pod-grace-period设置的时长；
      # ### 在eviction-max-pod-grace-period时长之后，如果POD还未退出则发送强制kill POD&quot;
      # eviction-soft: 'memory.available&lt;500Mi,nodefs.available&lt;50%,imagefs.available&lt;50%,nodefs.inodesFree&lt;10%'
      # eviction-soft-grace-period: 'memory.available=1m30s'
      # eviction-max-pod-grace-period: '30'
      # eviction-pressure-transition-period: '30s'
    cluster_domain: cluster.local
    infra_container_image: &quot;&quot;
    cluster_dns_server: 10.43.0.10
    fail_swap_on: false
  kubeproxy:
    extra_args:
      # 默认使用iptables进行数据转发，如果要启用ipvs，则此处设置为`ipvs`
      proxy-mode: &quot;ipvs&quot;
# 配置集群的CNI网络模型
network:
  plugin: canal
  options:
    flannel_backend_type: &quot;vxlan&quot;
ssh_key_path: ~/.ssh/id_rsa
ssh_agent_auth: false
authorization:
  mode: rbac
ignore_docker_version: false
# k8s的版本，可以通过rke config --system-images --all 命令列出所有rke支持的版本
kubernetes_version: v1.15.4-rancher1-2
# 国内使用阿里云的镜像
private_registries:
  - url: registry.cn-shanghai.aliyuncs.com
    user:
    password:
    is_default: true
# 配置ingress，目前RKE支持nginx。
ingress:
  provider: &quot;nginx&quot;
  # 节点选择，和上面node配置结合的
  node_selector:
    app: ingress
  options:
    use-forwarded-headers: &quot;true&quot;
cluster_name: rancher
addon_job_timeout: 0
restore:
  restore: false
  snapshot_name: &quot;&quot;

</code></pre>
<p>大部分的配置都注释说明了，基本上需要用到的配置就这些了，更详细的配置就需要看官方文档了。官方的连接https://docs.rancher.cn/rke/example-yamls.html</p>
<h2 id="开始部署">开始部署</h2>
<p>配置完毕之后，就是开始部署了，rke的启动非常简单，在配置文件目录使用<code>./rke up</code>就可以了<br>
启动完毕之后，等待大约10分钟左右，会提示<code>Finished building Kubernetes cluster successfully</code><br>
部署的过程中，日志可能会显示WARN的提示，这个是没有关系的。只要不出现ERR即可。</p>
<ul>
<li>可能会出现的错误</li>
</ul>
<ol>
<li>etcd健康检查不通过，出现证书错误的情况，这个报错一般是因为时间不同步导致的。</li>
<li>无法访问到node，这个报错一般是因为地址配置出错</li>
<li><code>Failed to set up SSH tunneling for host </code>，这个报错一般是使用了root用户或者docker sock配置错误</li>
<li><code>Failed to dial ssh using address</code>，ssh-key配置错误</li>
</ol>
<p>部署成功之后，有三个文件需要特别保存。</p>
<ul>
<li><code>cluster.yml</code>：RKE集群配置文件。</li>
<li><code>kube_config_cluster.yml</code>：集群的Kubeconfig文件，此文件包含完全访问集群的凭据。</li>
<li><code>cluster.rkestate</code>：Kubernetes集群状态文件，此文件包含集群部署的状态，用于升级和更新。</li>
</ul>
<p>有了以上三个文件，就可以对集群做新增、删除节点、升级集群版本的操作，所以必须要保存好。</p>
<h2 id="部署helm">部署Helm</h2>
<h3 id="创建helm权限">创建helm权限</h3>
<p>运行下面命令创建好helm的权限</p>
<pre><code>kubectl --kubeconfig=kube_config_cluster.yml -n kube-system create serviceaccount tiller

kubectl --kubeconfig=kube_config_cluster.yml create clusterrolebinding tiller \
--clusterrole cluster-admin --serviceaccount=kube-system:tiller
</code></pre>
<h3 id="初始化helm">初始化helm</h3>
<p>这里首先在自己的机子上装好helm，怎么装这里不再多说了，可以自行百度或者Google<br>
安装好了之后，可以直接运行<code>helm init --kubeconfig=kube_config_cluster.yml</code>来初始化。但是这里有有一个问题，可能会有镜像拉不下来的情况。所以推荐使用下面的命令来初始化。</p>
<pre><code>helm init --kubeconfig=kube_config_cluster.yml \
--service-account tiller --skip-refresh \
--tiller-image registry.cn-shanghai.aliyuncs.com/rancher/tiller:v2.14.1
</code></pre>
<p>里面的镜像是rancher给的镜像地址。当然也可以换成自己的。</p>
<p>运行完命令之后，可以通过kubectl看一看tiller是否正常启动了。</p>
<h4 id="更新helm">更新helm</h4>
<p>更新就直接使用kubectl的命令，升级镜像版本即可。命令如下（版本号可能和最新的不一样，请不要直接使用）</p>
<pre><code>kubectl --kubeconfig=kube_config_cluster.yml --namespace=kube-system \
  set image deployments/tiller-deploy \
  tiller=registry.cn-shanghai.aliyuncs.com/rancher/tiller:v3.0.1
</code></pre>
<h3 id="添加rancher的charts">添加rancher的charts</h3>
<p>添加rancher的stable版本charts</p>
<pre><code>helm repo add rancher-stable \
https://releases.rancher.com/server-charts/stable --kubeconfig=kube_config_cluster.yml
</code></pre>
<h3 id="安装rancher">安装rancher</h3>
<p>我这里使用的是外部负载均衡的模式，就是在k8s之外，还有一个nginx作为入口负载均衡，同时ssl也截至到这个nginx。所以下面的配置中，加上了<code>--set tls=external</code>。如果你是直接使用集群作为入口的，则不需要这个参数，需要自己配置ssl证书。具体参考官网。</p>
<pre><code>helm --kubeconfig=kube_config_cluster.yml install rancher-stable/rancher \
    --name rancher --namespace cattle-system \
    --set hostname=rancher.asoco.com.cn \
    --set tls=external
</code></pre>
<p>到此实际上整个集群和rancher都已经部署好了。接下来需要配置外部的nginx负载均衡器。</p>
<h3 id="外部负载均衡器nginx的配置">外部负载均衡器nginx的配置</h3>
<p>nginx的配置我直接贴出来：</p>
<pre><code># zip压缩相关的配置
gzip on;
gzip_disable &quot;msie6&quot;;
gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;
gzip_vary on;
gzip_static on;
gzip_proxied any;
gzip_min_length 0;
gzip_comp_level 8;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types
  text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml application/font-woff
  text/javascript application/javascript application/x-javascript
  text/x-json application/json application/x-web-app-manifest+json
  text/css text/plain text/x-component
  font/opentype application/x-font-ttf application/vnd.ms-fontobject font/woff2
  image/x-icon image/png image/jpeg;

# 这里配置为配置了ingress的work节点  
upstream rancher {
    server 192.168.1.5:80;
    server 192.168.1.6:80;
    server 192.168.1.7:80;
}

map $http_upgrade $connection_upgrade {
    default Upgrade;
    ''      close;
}

server {
    listen 443 ssl ;
    #配置域名
    server_name rancher.com.cn;
    #配置证书
    ssl_certificate /etc/nginx/rancher.com.cn.sslkey/fullchain.pem;
    ssl_certificate_key /etc/nginx/rancher.com.cn.sslkey/privkey.pem;

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://rancher;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        # This allows the ability for the execute shell window to remain open for up to 15 minutes. 
        ## Without this parameter, the default is 1 minute and will automatically close.
        proxy_read_timeout 900s;
        proxy_buffering off;
    }
}
# 配置301重定向
server {
    listen 80;
    server_name rancher.com.cn;
    return 301 https://$server_name$request_uri;
}

</code></pre>
<p>将以上配置，新增一个rancher.conf配置文件，然后放到/etc/nginx/conf.d/文件夹中，然后nginx重载配置即可。</p>
<h1 id="总结">总结</h1>
<p>在上面步骤都做完之后，访问域名即可打开rancher，并且rancher已经默认接管集群了，开始享有rancher的便捷吧。</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      浮生若梦
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://blog.muzim.cn/post/PmaL-uIiQ/" title="使用RKE部署一个k8s集群并部署Rancher HA">https://blog.muzim.cn/post/PmaL-uIiQ/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://blog.muzim.cn/tag/QNC8T5st1/"># kubernetes</a>
    
      <a href="https://blog.muzim.cn/tag/rkQFlt07z/"># k8s</a>
    
      <a href="https://blog.muzim.cn/tag/XTf6QFya9/"># docker</a>
    
      <a href="https://blog.muzim.cn/tag/R5Ken2nRw/"># 持续集成</a>
    
      <a href="https://blog.muzim.cn/tag/-lhVZc40P/"># linux</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="SonarQube代码扫码中代码覆盖率的计算公式" href="https://blog.muzim.cn/post/-TWSGE1cs/">SonarQube代码扫码中代码覆盖率的计算公式</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="SonarQube代码扫码中代码覆盖率的计算公式" href="https://blog.muzim.cn/post/-TWSGE1cs/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="利用YAPI和持续集成CI工具进行接口自动化测试" href="https://blog.muzim.cn/post/aNGEtf43Z/">利用YAPI和持续集成CI工具进行接口自动化测试</a>
        <a class="nav-mobile-next" title="利用YAPI和持续集成CI工具进行接口自动化测试" href="https://blog.muzim.cn/post/aNGEtf43Z/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('2019-03-01');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by Next | <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备2023003895号</a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "o(╥﹏╥)o不要离开我";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/BVx30SK1M/"" data-c="
          &lt;p&gt;本文会详细介绍如何编写一个Drone的pipeline文件&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;pipeline是什么&#34;&gt;Pipeline是什么？&lt;/h1&gt;
&lt;p&gt;pipeline的意思就是流水线，持续集成其实就是一个流水线工作，指定一系列的动作，然后让程序按顺序和条件去执行。所以写好一个pipeline就很重要。本文会介绍比较常用的pipeline流水线模式。&lt;/p&gt;
&lt;h1 id=&#34;编写pipeline&#34;&gt;编写Pipeline&lt;/h1&gt;
&lt;h2 id=&#34;drone的pipeline语法&#34;&gt;Drone的Pipeline语法&lt;/h2&gt;
&lt;p&gt;Drone的pipeline语法和k8s非常的相似，也是yaml文件。这里贴上nodejs的构建示例来作为展示(附带注释讲解)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#分隔符
---
#定义类型
kind: pipeline
#定义pipeline名字
name: default
#定义步骤，固定语法
steps:
#定义步骤的名字
  - name: restore-cache
  #定义该步骤用到的镜像
    image: drillster/drone-volume-cache
    #挂载缓存
    volumes:
    #挂载的名字
      - name: cache
      #挂载路径
        path: /cache
    #该步骤的设置（就是容器的环境变量）
    settings:
      restore: true
      mount:
        - ./node_modules
  #定义下一个步骤
  - name: build
  #所用到的镜像
    image: node:8.15
    #镜像运行时候的命令（就是docker里面的command）
    commands:
      - yarn config set registry https://registry.npm.taobao.org
      - yarn install
      - yarn run build
#缓存相关的
  - name: rebuild-cache
    image: drillster/drone-volume-cache
    volumes:
      - name: cache
        path: /cache
    settings:
      rebuild: true
      mount:
        - ./node_modules
    #当对应条件的时候才会执行
    when:
    #pipeline状态为成功和失败的时候。
      status:
        - success
        - failure

#设定挂载的路径
volumes:
  - name: cache
    host:
      path: /tmp/cache
  - name: docker
    host:
      path: /var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的yaml文件，我们定义了三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取出缓存中的内容&lt;/li&gt;
&lt;li&gt;使用yarn构建&lt;/li&gt;
&lt;li&gt;将新的缓存放回去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当pipeline被触发的时候，就会安装上面的步骤，依序执行。&lt;/p&gt;
&lt;h2 id=&#34;多个pipeline的执行&#34;&gt;多个Pipeline的执行&lt;/h2&gt;
&lt;p&gt;通常我们不止一个流水线，可能需要并行执行，执行完一个流水线后再执行其他的流水线。Drone一样可以做到，只需要加个分隔符即可。这和k8s里面是一样的，这里用nodejs项目构建同时执行代码扫描来做个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
kind: pipeline
name: build

steps:
  - name: build
    image: node:8.15
    commands:
      - yarn config set registry https://registry.npm.taobao.org
      - yarn install
      - yarn run build

---
kind: pipeline
name: scan

steps:
  - name: code-analysis
    image: aosapps/drone-sonar-plugin
    settings:
      sonar_host: http://sonar.asoco.com.cn
      sonar_token:
      #从密文获取（drone的secret设置）
        from_secret: sonar_token
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子就是同时执行，只需要写2个pipeline，然后用&lt;code&gt;---&lt;/code&gt;分割开即可。&lt;br&gt;
但是我们很多时候是需要为后一个pipeline设定条件的，比如我们规定构建成功后再做代码扫描，因为构建不成功，也就没有做代码扫描的必要了对吧。这里用上面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
kind: pipeline
name: build

steps:
  - name: build
    image: node:8.15
    commands:
      - yarn config set registry https://registry.npm.taobao.org
      - yarn install
      - yarn run build

---
kind: pipeline
name: scan

steps:
  - name: code-analysis
    image: aosapps/drone-sonar-plugin
    settings:
      sonar_host: http://sonar.asoco.com.cn
      sonar_token:
        from_secret: sonar_token

#只有上一个pipeline成功才会触发
trigger:
  status:
    - success

#在指定的pipeline完成之后进行验证
depends_on:
  - build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，再上面，我们只需要再需要加入条件的pipeline里面加上限制即可。也就是注释了的那几段。&lt;/p&gt;
&lt;h2 id=&#34;构建docker镜像&#34;&gt;构建docker镜像&lt;/h2&gt;
&lt;p&gt;由于drone是基于原生的docker来做持续集成的。所以构建docker镜像实际上就是用了docker in docker。官方也直接给了个示例。这里我依然用nodejs的项目作为例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
kind: pipeline
name: default

steps:
  - name: build
    image: node:8.15
    commands:
      - yarn config set registry https://registry.npm.taobao.org
      - yarn install
      - yarn run build

  - name: publish
    image: plugins/docker
    settings:
      mirror: https://docker.mirrors.ustc.edu.cn
      # 注册仓库（可以是harbor之类的地址）
      registry: registry.cn-hangzhou.aliyuncs.com 
       # docker仓库地址
      repo: registry.cn-hangzhou.aliyuncs.com/lm93129/drone-test
      #自动给镜像打tag，这里是根据推送上来的git信息来自动打tag的
      auto_tag: true
      #镜像仓库的账户密码
      password:
        from_secret: docker_password
      username:
        from_secret: docker_username
      purge: true
    #运行该步骤的条件
    when:
      branch:
        - master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里publish就是构建镜像并且推送镜像到镜像仓库了。plugins/docker这个镜像是固定的，drone官方给出的，有兴趣的，可以自己研究下这个镜像。主要的参数都有注释说明，还有其他问题可以看看官方的这个插件文档。&lt;/p&gt;
&lt;h2 id=&#34;通知推送&#34;&gt;通知推送&lt;/h2&gt;
&lt;p&gt;构建成功还是失败，肯定是需要来个钉钉、邮件、短信、微信之类的推送下对吧。&lt;br&gt;
这里以钉钉为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
kind: pipeline
name: default

steps:
  - name: dingtalk
    image: lddsb/drone-dingtalk-message
    settings:
    #钉钉的webhook token
      token:
        from_secret: dingding_token
    #推送的文本类型
      type: markdown
      #消息颜色
      message_color: true
      #分享链接
      sha_link: true
    when:
      status:
        - failure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个钉钉推送是lddsb制作的插件，当然如果想自己自定短语之类的，可以自己做个，比如你有自己的企业IM，需要做个推送，就可以自己写脚本，然后做成一个插件，然后就可以吧镜像换成自己的插件，来做消息推送了。&lt;/p&gt;
&lt;h1 id=&#34;结尾&#34;&gt;结尾&lt;/h1&gt;
&lt;p&gt;上面大部分的pipeline配置，里面用到的镜像都是官方收录的镜像，以及一些系统环境镜像。Drone的灵活在于可以自己轻松的定制镜像来实现各种各样的需求。以后有空，可能还会出一个Drone的镜像定制教程，实现自己写插件。&lt;/p&gt;
">Drone开源持续集成工具——Pipeline篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/IYdOb_aYG/"" data-c="
          &lt;p&gt;Drone是一个用Go语言开发的基于容器运行的开源持续集成软件。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Drone的github官方地址是：https://github.com/drone/drone&lt;br&gt;
官方说明文档（英文）地址是：https://docs.drone.io/&lt;/p&gt;
&lt;p&gt;截止我写完这篇文章，Drone的release版本为1.7.0&lt;br&gt;
所以本文以1.7.0为例说明drone的部署，由于Drone1.X前的版本有兼容性的问题，所以1.0之前的版本是不适用于本文所写的内容。不过相信应该大家都是用的新版本。&lt;/p&gt;
&lt;h1 id=&#34;部署方法&#34;&gt;部署方法&lt;/h1&gt;
&lt;p&gt;Drone作为一个开源持续集成工具，和Jenkins不一样的是，他本身不带有用户管理系统，而是对接的代码管理系统。所以根据自己目前使用的代码仓库管理系统来进行部署。这里以gitlab社区版为例进行部署，其他的部署方式都大同小异，基本一样，参考下官方说明文档即可。&lt;/p&gt;
&lt;h2 id=&#34;单drone服务&#34;&gt;单Drone服务&lt;/h2&gt;
&lt;h3 id=&#34;创建一个oauth应用程序&#34;&gt;创建一个OAuth应用程序&lt;/h3&gt;
&lt;p&gt;创建一个GitLab OAuth应用程序。使用者密钥和使用者密钥用于授权访问GitLab资源。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://yanxuan.nosdn.127.net/6810ecf67a439c90590e817522c5b4cb.png&#34; alt=&#34;gitlab_token_create.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://yanxuan.nosdn.127.net/87df82ebdc50eaaffc58591672afb01c.png&#34; alt=&#34;UTOOLS1588920592860.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;授权回调URL必须与是正确的drone服务器地址，而且要在地址的结尾加上/login。&lt;/li&gt;
&lt;li&gt;举例drone的地址为http://drone.com.cn，则回调地址为http://drone.com.cn/login&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建slave通讯密匙&#34;&gt;创建slave通讯密匙&lt;/h3&gt;
&lt;p&gt;创建一个共享密钥，以验证slave runner与Drone服务器之间的通信。&lt;br&gt;
这里可以使用openssl生成共享密匙：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openssl rand -hex 16
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker启动&#34;&gt;docker启动&lt;/h3&gt;
&lt;p&gt;使用以下命令启动服务器容器。容器是通过环境变量配置的。有关配置参数的说明，会在下面解释。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run \
  --volume=/var/lib/drone:/data \
  --env=DRONE_GITLAB_SERVER=https://gitlab.com \
  --env=DRONE_GITLAB_CLIENT_ID={{DRONE_GITLAB_CLIENT_ID}} \
  --env=DRONE_GITLAB_CLIENT_SECRET={{DRONE_GITLAB_CLIENT_SECRET}} \
  --env=DRONE_RPC_SECRET={{DRONE_RPC_SECRET}} \
  --env=DRONE_SERVER_HOST={{DRONE_SERVER_HOST}} \
  --env=DRONE_SERVER_PROTO={{DRONE_SERVER_PROTO}} \
  --publish=80:80 \
  --publish=443:443 \
  --restart=always \
  --detach=true \
  --name=drone \
  drone/drone:1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DRONE_GITLAB_CLIENT_ID&lt;br&gt;
GitLab oauth客户端ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_GITLAB_CLIENT_SECRET&lt;br&gt;
GitLab oauth客户端密钥&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_GITLAB_SERVER&lt;br&gt;
GitLab服务器网址，例如https://gitlab.com&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_GIT_ALWAYS_AUTH&lt;br&gt;
克隆公共存储库时进行身份验证，这个是可选的选项，为bool值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RPC_SECRET&lt;br&gt;
上一步生成的通讯密匙&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_SERVER_HOST&lt;br&gt;
drone的服务器地址，例如drone.com.cn&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_SERVER_PROTO&lt;br&gt;
drone的访问协议，如http或者https。如果设置了acme的话，这里默然为https&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据会挂载到/var/lib/drone这个目录，如果需要备份数据，则备份这个目录即可&lt;br&gt;
更多的环境变量配置可以参考官方文档：https://docs.drone.io/server/reference/&lt;/p&gt;
&lt;h2 id=&#34;slave-runner节点部署&#34;&gt;slave runner节点部署&lt;/h2&gt;
&lt;p&gt;上面的drone服务器安装完成后，如果需要增加slave runner，则可以自己部署slave&lt;/p&gt;
&lt;h3 id=&#34;选择部署的slave类型&#34;&gt;选择部署的slave类型&lt;/h3&gt;
&lt;p&gt;drone的slave类型也有很多，比如Windows、Linux的Docker Runner、kubernetes Runner、ssh Runner、Exec Runner。&lt;br&gt;
根据实际情况，我们可以选择性的部署，或者都部署，并为部署的节点打上标签，方便在不同的情况下使用，这里以Linux的Docker Runner为例，举例说明如何部署。其他的部署方式，可以参考官方文档：https://docs.drone.io/runner/overview/&lt;/p&gt;
&lt;h3 id=&#34;linux-docker-runner&#34;&gt;Linux Docker Runner&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run -d \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -e DRONE_RPC_PROTO=https \
  -e DRONE_RPC_HOST=drone.company.com \
  -e DRONE_RPC_SECRET=super-duper-secret \
  -e DRONE_RUNNER_CAPACITY=2 \
  -e DRONE_RUNNER_LABELS=linux \
  -e DRONE_RUNNER_MAX_PROCS=10 \
  -e DRONE_RUNNER_NAME=slave-runner \
  -e DRONE_RUNNER_CAPACITY=2 \
  -e DRONE_RUNNER_NAME=${HOSTNAME} \
  -p 3000:3000 \
  --restart always \
  --name runner \
  drone/drone-runner-docker:1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RPC_HOST&lt;br&gt;
Drone的服务器地址，例如drone.com.cn&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RPC_PROTO&lt;br&gt;
Drone的连接协议，必须是http或者https&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RPC_SECRET&lt;br&gt;
部署Drone的时候生成的通讯密匙&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RUNNER_LABELS&lt;br&gt;
给runner打个标签，方便标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RUNNER_NAME&lt;br&gt;
给runner取个名字，方便标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RUNNER_MAX_PROCS&lt;br&gt;
runner可以运行的单个管道最大并发步骤数（就是一个pipeline里面，可以同时跑的任务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRONE_RUNNER_CAPACITY&lt;br&gt;
runner可以运行的最大并发管道数（可以同时运行几个pipeline）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;部署成功后打开&#34;&gt;部署成功后打开&lt;/h1&gt;
&lt;p&gt;部署成功后，直接输入&lt;code&gt;DRONE_SERVER_HOST&lt;/code&gt;的地址，能够成功访问就可以了，在右上角可以登录，登录的时候自动跳转到gitlab，然后登录gitlab的账户即可。drone的仓库访问权限和gitlab是相同的。如果在drone中看不到自己的项目，可以点击sync同步下仓库信息&lt;/p&gt;
">Drone开源持续集成工具——部署教程篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/-TWSGE1cs/"" data-c="
          &lt;p&gt;想必有很多人不太理解SonarQube中关于代码覆盖率的计算方法。对于覆盖率、分支覆盖率、分支覆盖率等这些的区别&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;首先，先来看下覆盖率的图，再根据图上SonarQube汉化的术语来说明下：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2020/03/25/qbkRu5cYNoZa1p9.png&#34; alt=&#34;覆盖率截图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里由于翻译的问题，所以会导致有点不明所以。搞不懂为啥要按照下面的公式计算。所以这里对公式中的术语做个简单的说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CT：条件至少一次为“true”的分支&lt;/li&gt;
&lt;li&gt;CE：条件至少一次为“false”的分支&lt;/li&gt;
&lt;li&gt;B：分支的总数量&lt;/li&gt;
&lt;li&gt;EL：可执行的代码行数&lt;/li&gt;
&lt;li&gt;LC：覆盖的行数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;覆盖率&#34;&gt;覆盖率&lt;/h1&gt;
&lt;p&gt;覆盖率的计算是一个简单的公式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;覆盖率 = （CT+CF+LC）/（2B+EL）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按照图中汉化的术语来计算则：&lt;br&gt;
CT+CF= 分支覆盖率-未覆盖分支&lt;br&gt;
2B= 分支覆盖率&lt;br&gt;
EL= 代码行&lt;br&gt;
LC= 代码行-未覆盖的代码&lt;/p&gt;
&lt;p&gt;SonarQube中的这个覆盖率，就是综合考虑行覆盖率和分支覆盖率后计算出来。为什么既要考虑行覆盖率又要考虑分支覆盖率呢，下面会给出解释。&lt;/p&gt;
&lt;h1 id=&#34;行覆盖率&#34;&gt;行覆盖率&lt;/h1&gt;
&lt;p&gt;行覆盖率是一个简单的公式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;行覆盖率= LC/EL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种覆盖率统计方式是最为基础的，它可以用于体现参测代码中已被执行和未被执行的代码行（语句），从而可以进一步推断代码的逻辑覆盖是否全面。&lt;/p&gt;
&lt;h1 id=&#34;分支覆盖率&#34;&gt;分支覆盖率&lt;/h1&gt;
&lt;p&gt;分支覆盖率的公式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;分支覆盖率= （CT+CF）/2B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种覆盖率统计方式是用于统计代码中所有判断分支是否都被覆盖，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (condition)
{
    Operation_1();
} 
else 
{
    Operation_2();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;语句就会根据 condition 的值产生两个不同的分支操作，那么在统计分支覆盖时，就需要对两个分支都进行校验。值得注意的是，上例中的代码，其分支覆盖可以被行覆盖所取代，也就是说若上面代码的行覆盖率为100%， 则其分支覆盖率亦为100%。&lt;/p&gt;
&lt;p&gt;但是如果python常见的那种三元表达式的条件判断，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;condition ? Operation_1() : Operation_2();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在行覆盖率中，只要这一行执行过，就为100%，所以只看行覆盖率，就不太行，需要综合考虑二者&lt;/p&gt;
">SonarQube代码扫码中代码覆盖率的计算公式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/PmaL-uIiQ/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85rke&#34;&gt;安装RKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4&#34;&gt;部署k8s集群&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%9F%E6%88%90%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;生成集群配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%80%E5%A7%8B%E9%83%A8%E7%BD%B2&#34;&gt;开始部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2helm&#34;&gt;部署Helm&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BAhelm%E6%9D%83%E9%99%90&#34;&gt;创建helm权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96helm&#34;&gt;初始化helm&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9B%B4%E6%96%B0helm&#34;&gt;更新helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%BB%E5%8A%A0rancher%E7%9A%84charts&#34;&gt;添加rancher的charts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85rancher&#34;&gt;安装rancher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%96%E9%83%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8nginx%E7%9A%84%E9%85%8D%E7%BD%AE&#34;&gt;外部负载均衡器nginx的配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
RKE全称为Rancher Kubernetes Engine，是rancher开源的轻量级k8s集群部署工具，使用他可以快速的部署一个k8s集群&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;安装rke&#34;&gt;安装RKE&lt;/h1&gt;
&lt;p&gt;首先需要下载RKE这个工具，下载地址为：https://github.com/rancher/rke/releases&lt;br&gt;
根据自己的平台，下载对应的可执行文件，下面我以ubuntu来做演示说明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载rke_linux_amd64&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chmod +x rke_linux_amd64&lt;/code&gt;赋予可执行权限&lt;/li&gt;
&lt;li&gt;改名为rke，&lt;code&gt;mv rke_linux_amd64 rke&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;放入bin目录（可选）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上三步就安装好了RKE，mac可以直接用brew安装，命令为&lt;code&gt;brew install rke&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;部署k8s集群&#34;&gt;部署k8s集群&lt;/h1&gt;
&lt;h2 id=&#34;生成集群配置文件&#34;&gt;生成集群配置文件&lt;/h2&gt;
&lt;p&gt;安装好了RKE之后，首先生成RKE的配置文件。&lt;br&gt;
使用自带命令&lt;code&gt;rke config&lt;/code&gt;，生成&lt;code&gt;cluster.yml&lt;/code&gt;配置文件&lt;/p&gt;
&lt;p&gt;生成之后默认会有一个示例的配置文件。文件中的controlplane 就是k8s中所说的master。下面来看下这个配置文件(已经经过修改的版本)。&lt;br&gt;
我们以3主3etcd，3work这种经典k8s集群模式来讲解下配置文件改如何写。请仔细阅读，对于部署k8s有以下几点需要注意的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;账户不能用root账户&lt;/li&gt;
&lt;li&gt;所有节点的时间必须同步&lt;/li&gt;
&lt;li&gt;使用的非root账户要能正常使用docker&lt;/li&gt;
&lt;li&gt;配置建议再2C4G以上，推荐是4C8G比较合适，磁盘40G&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;nodes:
  - address: 192.168.1.1
    port: &amp;quot;22&amp;quot; # ssh 端口
    internal_address: &amp;quot;&amp;quot; # 内网IP，如果是公有云的这种有公私网两个IP的，则address配置为公网IP
    role:
      - controlplane  # 控制节点角色，等于k8s的master
      - etcd
    user: ubuntu  # 服务器登陆账户
    hostname_override: master-etcd-01
    docker_socket: /var/run/docker.sock  # docker sock所在路径，如果是用snap安装的dockers需要自行修改
    ssh_key_path: &amp;quot;~/.ssh/id_rsa&amp;quot;  # ssh key的路径，必须是免密登录，不能使用账户密码
    labels: {} # 标签说明
  - address: 192.168.1.2
    port: &amp;quot;22&amp;quot;
    internal_address: &amp;quot;&amp;quot;
    role:
      - controlplane
      - etcd
    user: ubuntu
    hostname_override: master-etcd-02
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
  - address: 192.168.1.3
    port: &amp;quot;22&amp;quot;
    internal_address: &amp;quot;&amp;quot;
    role:
      - controlplane
      - etcd
    user: ubuntu
    hostname_override: master-etcd-03
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
  - address: 192.168.1.4
    port: &amp;quot;22&amp;quot;
    internal_address: &amp;quot;&amp;quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-1
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress  # 标记后只有该标记节点会部署ingress
  - address: 192.168.1.6
    port: &amp;quot;22&amp;quot;
    internal_address: &amp;quot;&amp;quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-2
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress
  - address: 192.168.1.7
    port: &amp;quot;22&amp;quot;
    internal_address: &amp;quot;&amp;quot;
    role:
      - worker
    user: ubuntu
    hostname_override: worker-3
    docker_socket: /var/run/docker.sock
    ssh_key_path: ~/.ssh/id_rsa
    labels:
      app: ingress
services:
# ETCD相关配置，另外备份是可以备份到s3的，这个配置见官方文档
  etcd:
    extra_args:
      auto-compaction-retention: 240 #(单位小时)
      # 修改空间配额为$((6*1024*1024*1024))，默认2G,最大8G
      quota-backend-bytes: &amp;quot;6442450944&amp;quot;
    backup_config:
      enabled: true
      interval_hours: 12
      retention: 6
  kube-api:
    service_cluster_ip_range: 10.43.0.0/16
    service_node_port_range: &amp;quot;20000-40000&amp;quot;
    pod_security_policy: false
    always_pull_images: false
# 控制器的一些配置，比如节点判断失联后多久开始迁移等
  kube-controller:
    extra_args:
      ## 当节点通信失败后，再等一段时间kubernetes判定节点为notready状态。
      ## 这个时间段必须是kubelet的nodeStatusUpdateFrequency(默认10s)的整数倍，
      ## 其中N表示允许kubelet同步节点状态的重试次数，默认40s。
      node-monitor-grace-period: &amp;quot;20s&amp;quot;
      ## 再持续通信失败一段时间后，kubernetes判定节点为unhealthy状态，默认1m0s。
      node-startup-grace-period: &amp;quot;30s&amp;quot;
      ## 再持续失联一段时间，kubernetes开始迁移失联节点的Pod，默认5m0s。
      pod-eviction-timeout: &amp;quot;1m&amp;quot;
    cluster_cidr: 10.42.0.0/16
    service_cluster_ip_range: 10.43.0.0/16
# 集群的一些配置，包括资源预留，集群名字，dns等配置
  kubelet:
    extra_args:
      serialize-image-pulls: &amp;quot;false&amp;quot;
      registry-burst: &amp;quot;10&amp;quot;
      registry-qps: &amp;quot;0&amp;quot;
      # # 节点资源预留
      # enforce-node-allocatable: &#39;pods&#39;
      # system-reserved: &#39;cpu=0.5,memory=500Mi&#39;
      # kube-reserved: &#39;cpu=0.5,memory=1500Mi&#39;
      # # POD驱逐，这个参数只支持内存和磁盘。
      # ## 硬驱逐伐值
      # ### 当节点上的可用资源降至保留值以下时，就会触发强制驱逐。强制驱逐会强制kill掉POD，不会等POD自动退出。
      # eviction-hard: &#39;memory.available&amp;lt;300Mi,nodefs.available&amp;lt;10%,imagefs.available&amp;lt;15%,nodefs.inodesFree&amp;lt;5%&#39;
      # ## 软驱逐伐值
      # ### 以下四个参数配套使用，当节点上的可用资源少于这个值时但大于硬驱逐伐值时候，会等待eviction-soft-grace-period设置的时长；
      # ### 等待中每10s检查一次，当最后一次检查还触发了软驱逐伐值就会开始驱逐，驱逐不会直接Kill POD，先发送停止信号给POD，然后等待eviction-max-pod-grace-period设置的时长；
      # ### 在eviction-max-pod-grace-period时长之后，如果POD还未退出则发送强制kill POD&amp;quot;
      # eviction-soft: &#39;memory.available&amp;lt;500Mi,nodefs.available&amp;lt;50%,imagefs.available&amp;lt;50%,nodefs.inodesFree&amp;lt;10%&#39;
      # eviction-soft-grace-period: &#39;memory.available=1m30s&#39;
      # eviction-max-pod-grace-period: &#39;30&#39;
      # eviction-pressure-transition-period: &#39;30s&#39;
    cluster_domain: cluster.local
    infra_container_image: &amp;quot;&amp;quot;
    cluster_dns_server: 10.43.0.10
    fail_swap_on: false
  kubeproxy:
    extra_args:
      # 默认使用iptables进行数据转发，如果要启用ipvs，则此处设置为`ipvs`
      proxy-mode: &amp;quot;ipvs&amp;quot;
# 配置集群的CNI网络模型
network:
  plugin: canal
  options:
    flannel_backend_type: &amp;quot;vxlan&amp;quot;
ssh_key_path: ~/.ssh/id_rsa
ssh_agent_auth: false
authorization:
  mode: rbac
ignore_docker_version: false
# k8s的版本，可以通过rke config --system-images --all 命令列出所有rke支持的版本
kubernetes_version: v1.15.4-rancher1-2
# 国内使用阿里云的镜像
private_registries:
  - url: registry.cn-shanghai.aliyuncs.com
    user:
    password:
    is_default: true
# 配置ingress，目前RKE支持nginx。
ingress:
  provider: &amp;quot;nginx&amp;quot;
  # 节点选择，和上面node配置结合的
  node_selector:
    app: ingress
  options:
    use-forwarded-headers: &amp;quot;true&amp;quot;
cluster_name: rancher
addon_job_timeout: 0
restore:
  restore: false
  snapshot_name: &amp;quot;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大部分的配置都注释说明了，基本上需要用到的配置就这些了，更详细的配置就需要看官方文档了。官方的连接https://docs.rancher.cn/rke/example-yamls.html&lt;/p&gt;
&lt;h2 id=&#34;开始部署&#34;&gt;开始部署&lt;/h2&gt;
&lt;p&gt;配置完毕之后，就是开始部署了，rke的启动非常简单，在配置文件目录使用&lt;code&gt;./rke up&lt;/code&gt;就可以了&lt;br&gt;
启动完毕之后，等待大约10分钟左右，会提示&lt;code&gt;Finished building Kubernetes cluster successfully&lt;/code&gt;&lt;br&gt;
部署的过程中，日志可能会显示WARN的提示，这个是没有关系的。只要不出现ERR即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能会出现的错误&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;etcd健康检查不通过，出现证书错误的情况，这个报错一般是因为时间不同步导致的。&lt;/li&gt;
&lt;li&gt;无法访问到node，这个报错一般是因为地址配置出错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed to set up SSH tunneling for host &lt;/code&gt;，这个报错一般是使用了root用户或者docker sock配置错误&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed to dial ssh using address&lt;/code&gt;，ssh-key配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;部署成功之后，有三个文件需要特别保存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cluster.yml&lt;/code&gt;：RKE集群配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube_config_cluster.yml&lt;/code&gt;：集群的Kubeconfig文件，此文件包含完全访问集群的凭据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster.rkestate&lt;/code&gt;：Kubernetes集群状态文件，此文件包含集群部署的状态，用于升级和更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上三个文件，就可以对集群做新增、删除节点、升级集群版本的操作，所以必须要保存好。&lt;/p&gt;
&lt;h2 id=&#34;部署helm&#34;&gt;部署Helm&lt;/h2&gt;
&lt;h3 id=&#34;创建helm权限&#34;&gt;创建helm权限&lt;/h3&gt;
&lt;p&gt;运行下面命令创建好helm的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl --kubeconfig=kube_config_cluster.yml -n kube-system create serviceaccount tiller

kubectl --kubeconfig=kube_config_cluster.yml create clusterrolebinding tiller \
--clusterrole cluster-admin --serviceaccount=kube-system:tiller
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化helm&#34;&gt;初始化helm&lt;/h3&gt;
&lt;p&gt;这里首先在自己的机子上装好helm，怎么装这里不再多说了，可以自行百度或者Google&lt;br&gt;
安装好了之后，可以直接运行&lt;code&gt;helm init --kubeconfig=kube_config_cluster.yml&lt;/code&gt;来初始化。但是这里有有一个问题，可能会有镜像拉不下来的情况。所以推荐使用下面的命令来初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm init --kubeconfig=kube_config_cluster.yml \
--service-account tiller --skip-refresh \
--tiller-image registry.cn-shanghai.aliyuncs.com/rancher/tiller:v2.14.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面的镜像是rancher给的镜像地址。当然也可以换成自己的。&lt;/p&gt;
&lt;p&gt;运行完命令之后，可以通过kubectl看一看tiller是否正常启动了。&lt;/p&gt;
&lt;h4 id=&#34;更新helm&#34;&gt;更新helm&lt;/h4&gt;
&lt;p&gt;更新就直接使用kubectl的命令，升级镜像版本即可。命令如下（版本号可能和最新的不一样，请不要直接使用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl --kubeconfig=kube_config_cluster.yml --namespace=kube-system \
  set image deployments/tiller-deploy \
  tiller=registry.cn-shanghai.aliyuncs.com/rancher/tiller:v3.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加rancher的charts&#34;&gt;添加rancher的charts&lt;/h3&gt;
&lt;p&gt;添加rancher的stable版本charts&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm repo add rancher-stable \
https://releases.rancher.com/server-charts/stable --kubeconfig=kube_config_cluster.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装rancher&#34;&gt;安装rancher&lt;/h3&gt;
&lt;p&gt;我这里使用的是外部负载均衡的模式，就是在k8s之外，还有一个nginx作为入口负载均衡，同时ssl也截至到这个nginx。所以下面的配置中，加上了&lt;code&gt;--set tls=external&lt;/code&gt;。如果你是直接使用集群作为入口的，则不需要这个参数，需要自己配置ssl证书。具体参考官网。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm --kubeconfig=kube_config_cluster.yml install rancher-stable/rancher \
    --name rancher --namespace cattle-system \
    --set hostname=rancher.asoco.com.cn \
    --set tls=external
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此实际上整个集群和rancher都已经部署好了。接下来需要配置外部的nginx负载均衡器。&lt;/p&gt;
&lt;h3 id=&#34;外部负载均衡器nginx的配置&#34;&gt;外部负载均衡器nginx的配置&lt;/h3&gt;
&lt;p&gt;nginx的配置我直接贴出来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# zip压缩相关的配置
gzip on;
gzip_disable &amp;quot;msie6&amp;quot;;
gzip_disable &amp;quot;MSIE [1-6]\.(?!.*SV1)&amp;quot;;
gzip_vary on;
gzip_static on;
gzip_proxied any;
gzip_min_length 0;
gzip_comp_level 8;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types
  text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml application/font-woff
  text/javascript application/javascript application/x-javascript
  text/x-json application/json application/x-web-app-manifest+json
  text/css text/plain text/x-component
  font/opentype application/x-font-ttf application/vnd.ms-fontobject font/woff2
  image/x-icon image/png image/jpeg;

# 这里配置为配置了ingress的work节点  
upstream rancher {
    server 192.168.1.5:80;
    server 192.168.1.6:80;
    server 192.168.1.7:80;
}

map $http_upgrade $connection_upgrade {
    default Upgrade;
    &#39;&#39;      close;
}

server {
    listen 443 ssl ;
    #配置域名
    server_name rancher.com.cn;
    #配置证书
    ssl_certificate /etc/nginx/rancher.com.cn.sslkey/fullchain.pem;
    ssl_certificate_key /etc/nginx/rancher.com.cn.sslkey/privkey.pem;

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://rancher;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        # This allows the ability for the execute shell window to remain open for up to 15 minutes. 
        ## Without this parameter, the default is 1 minute and will automatically close.
        proxy_read_timeout 900s;
        proxy_buffering off;
    }
}
# 配置301重定向
server {
    listen 80;
    server_name rancher.com.cn;
    return 301 https://$server_name$request_uri;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将以上配置，新增一个rancher.conf配置文件，然后放到/etc/nginx/conf.d/文件夹中，然后nginx重载配置即可。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;在上面步骤都做完之后，访问域名即可打开rancher，并且rancher已经默认接管集群了，开始享有rancher的便捷吧。&lt;/p&gt;
">使用RKE部署一个k8s集群并部署Rancher HA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/aNGEtf43Z/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#yapi%E5%AF%BC%E5%85%A5swagger%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE&#34;&gt;YAPI导入swagger的接口数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B&#34;&gt;编写测试用例&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%BB%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83&#34;&gt;添加测试环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%85%A5ci%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96&#34;&gt;接入CI实现自动化&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%85%A5%E5%88%B0drone-ci&#34;&gt;接入到drone-ci&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%85%A5%E5%85%B6%E5%AE%83%E7%9A%84ci%E7%A8%8B%E5%BA%8F&#34;&gt;接入其它的ci程序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%8E%E8%AF%9D&#34;&gt;后话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
YAPI是一个高效、易用、功能强大的 api 管理平台，可以在上面进行接口的集中管理，并且支持直接导入和自动更新swagger的接口数据。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;yapi导入swagger的接口数据&#34;&gt;YAPI导入swagger的接口数据&lt;/h1&gt;
&lt;p&gt;目前大多数的开发写接口文档都会使用swagger。YAPI很好的兼容了这点，可以直接从swagger导入数据。&lt;br&gt;
首先在YAPI中创建一个项目，然后选择数据管理，如下图所示，导入swagger。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/05/5CNvwQYRAPsprV6.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何获取swagger的json连接呢。swagger有2个版本,获取方式分别如下图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/09/05/rhoayvZ8xquIiEK.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/05/CMk3vtui1eofaBZ.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;编写测试用例&#34;&gt;编写测试用例&lt;/h1&gt;
&lt;p&gt;导入完成之后，有些接口可能需要配置一些请求头之类的，这个就需要单独调整了。目前swagger导入的时候，不会导入认证用的请求头信息。这就需要你自己调整了。这里就不过多的描述了，可以去看yapi的文档。&lt;/p&gt;
&lt;p&gt;配置完接口之后，切换到测试集合标签。在这里添加测试集合。把之前的接口添加进来。通常先添加登录接口，获取认证，然后再添加其他的接口。&lt;/p&gt;
&lt;p&gt;YAPI可以传递请求参数的，并且是由上至下的请求顺序。所以顺序很重要。这里有官方文档可以参考。这里我附上地址供参考：&lt;a href=&#34;https://hellosean1025.github.io/yapi/documents/case.html#%e7%ac%ac%e4%b8%80%e6%ad%a5%ef%bc%8c%e6%b5%8b%e8%af%95%e9%9b%86%e5%90%88&#34;&gt;YAPI测试集合教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;添加测试环境&#34;&gt;添加测试环境&lt;/h2&gt;
&lt;p&gt;有时候我们会有多个环境，比如测试环境、开发环境、预发布环境、生产环境等。在项目的设置中，我们可以添加多个环境，并且配置一些这个环境的全局参数，比如如果有AB测试，是通过Header区分的，就可以在这里配置。界面如下图所示：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/05/Qv8ESy2pRtcY75i.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;接入ci实现自动化&#34;&gt;接入CI实现自动化&lt;/h1&gt;
&lt;p&gt;编写好之后，需要先运行一次，测试一下看看自己编写的测试用例是否通过，通过了，就可以接入到ci中运行了。在测试集合界面选择服务端测试，可以得到一个链接，如下图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/09/05/hCzWZB8LrJQ4Hmi.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里可以用脚本或者其他的程序通过get请求来请求这个URL，实现自动化。这里我写了一个插件，并且做好了docker镜像，可以直接使用，附上github地址：&lt;a href=&#34;https://github.com/lm93129/drone_yapi_test&#34;&gt;drone_yapi_test&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;初学go语言，代码写的有点烂，欢迎大佬pr&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;插件的使用方法很简单。直接docker运行的话，就是下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --rm \
  -e PLUGIN_HOST=http://yapi.com.cn \
  -e PLUGIN_TOKEN=ab1058076e0945cf14 \
  -e PLUGIN_ID=&amp;quot;11,31,15&amp;quot; \
  -e PLUGIN_ENV=&amp;quot;env_11=网关地址&amp;quot; \
  registry.cn-hangzhou.aliyuncs.com/lm93129/drone_yapi_test:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有4个参数。我来解释下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PLUGIN_HOST这个就是yapi的地址，记得地址不能是https://yapi.com.cn/ 这种以/结尾的&lt;/li&gt;
&lt;li&gt;PLUGIN_TOKEN这个就是你yapi账户的token&lt;/li&gt;
&lt;li&gt;PLUGIN_ID这个是你测试集合的ID&lt;/li&gt;
&lt;li&gt;PLUGIN_ENV这个就是你的测试集合要运行的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么获取上面的四个参数呢？其实很简单，首先host就不用说了。其它的参数都可以通过上面我们获取到的那个URL提取出来。我这里的示例上，ID是有多个的，这里解释下，因为我们可能需要运行多个测试集合，所以当你输入多个ID的时候，插件就会按顺序运行每个测试集合。&lt;/p&gt;
&lt;h2 id=&#34;接入到drone-ci&#34;&gt;接入到drone-ci&lt;/h2&gt;
&lt;p&gt;由于我用的是drone这个ci工具，所以这里演示下这个插件在drone里面是怎么运行的。drone中的pipeline写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - name: yapi-test
    image: registry.cn-hangzhou.aliyuncs.com/lm93129/drone_yapi_test:latest
    settings:
      host: http://yapi.com.cn/
      id: [11,19]
      token: ab105800479fdb69cd8f485f86b7776e0945cf14
      env: env_11=网关地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行的结果呢，就是下面这样：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/09/05/dmcwF6W1axHL7Qv.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果过程中有不通过的接口，ci就不通过，然后就会触发ci的钉钉通知。&lt;/p&gt;
&lt;h2 id=&#34;接入其它的ci程序&#34;&gt;接入其它的ci程序&lt;/h2&gt;
&lt;p&gt;对于其它的ci程序接入，可以参考上面的docker运行方式进行接入。不过要求就是需要支持docker。现在绝大多数的CI应该都支持docker了。&lt;/p&gt;
&lt;h1 id=&#34;后话&#34;&gt;后话&lt;/h1&gt;
&lt;p&gt;这个插件还是有一些不完善的地方的。以后可能还会更新一些版本，如果有更好的建议欢迎提issue和pr。&lt;/p&gt;
&lt;p&gt;之后会写一些drone这个持续集成工具的使用。我挺喜欢这个工具的，感觉很方便。&lt;/p&gt;
">利用YAPI和持续集成CI工具进行接口自动化测试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/7UEVRVfNj/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%91%E5%B8%83%E5%9C%BA%E6%99%AF&#34;&gt;发布场景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E4%B8%80&#34;&gt;场景一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E4%BA%8C&#34;&gt;场景二&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E&#34;&gt;注解说明&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E4%BA%8Erequest-header%E7%9A%84%E6%B5%81%E9%87%8F%E5%88%87%E5%88%86&#34;&gt;基于Request Header的流量切分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E4%BA%8Ecookie%E7%9A%84%E6%B5%81%E9%87%8F%E5%88%87%E5%88%86&#34;&gt;基于Cookie的流量切分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%87%8D%E7%9A%84%E6%B5%81%E9%87%8F%E5%88%87%E5%88%86&#34;&gt;基于服务权重的流量切分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9&#34;&gt;三种注释的优先级和注意点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
nginx-ingress作为K8S集群对外的流量入口，充当K8S集群内各个service的反向代理。日常工作中我们经常需要对服务进行版本更新升级，为此我们经常使用到的发布方式有滚动升级、分批暂停发布、蓝绿发布以及灰度发布等不同的发布操作。所以下面介绍下，通过配置nginx annotations来实现不同场景下的发布和测试。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;发布场景&#34;&gt;发布场景&lt;/h1&gt;
&lt;h2 id=&#34;场景一&#34;&gt;场景一&lt;/h2&gt;
&lt;p&gt;假设当前线上环境我们已经有一套服务Service A对外提供7层服务，此时我们新开发了一些新的特性，需要灰度发布上线一个新的版本Service A&#39;，但是我们暂时又不希望简单地直接替换掉Service A服务，而是希望将请求头中包含foo=bar或者cookie中包含foo=bar的客户端请求转发到Service A&#39;服务中，待运行一段时间稳定，将所有的流量切换到Service A&#39;服务中后，再平滑地下线掉Service A服务：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/25/5d11da118f60f25662.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;场景二&#34;&gt;场景二&lt;/h2&gt;
&lt;p&gt;假设当前线上环境我们已经有一套服务Service B对外提供7层服务，此时我们修复了一些问题，需要灰度发布上线一个新的版本Service B&#39;，但是我们又不希望简单直接地将所有客户端流量切换到新版本Service B&#39;中，而是希望仅仅切换20%的流量到新版本Service B&#39;中，待运行一段时间稳定，将所有的流量切换到Service B&#39;服务中后，再平滑地下线掉Service B服务：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/25/5d11da2887ed225183.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;针对以上多种不同的应用发布需求，nginx Ingress 支持了多种流量切分方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于Request Header的流量切分，适用于灰度发布以及AB测试场景&lt;/li&gt;
&lt;li&gt;基于Cookie的流量切分，适用于灰度发布以及AB测试场景&lt;/li&gt;
&lt;li&gt;基于服务权重的流量切分，适用于蓝绿发布场景&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;注解说明&#34;&gt;注解说明&lt;/h1&gt;
&lt;p&gt;K8S Ingress Controller通过下列Annotation来支持应用服务的不同发布机制，首先需要设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nginx.ingress.kubernetes.io/canary: &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后根据需要求设定对应的配置&lt;/p&gt;
&lt;h2 id=&#34;基于request-header的流量切分&#34;&gt;基于Request Header的流量切分&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nginx.ingress.kubernetes.io/canary-by-header：&lt;/code&gt;用于通知Ingress将请求路由到Canary Ingress中指定的服务的标头。当请求标头设置always为时，它将被路由到Canary。当标头设置never为时，它将永远不会被路由到Canary。对于任何其他值，将忽略标头，并通过优先级将请求与其他Canary规则进行比较。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nginx.ingress.kubernetes.io/canary-by-header-value：&lt;/code&gt;要匹配的标头值，用于通知Ingress将请求路由到Canary Ingress中指定的服务。当请求标头设置为此值时，它将被路由到Canary。对于任何其他标头值，标头将被忽略，并且请求与其他Canary规则的优先级进行比较。此注释必须与canary-by-header一起使用。注释是&lt;code&gt;nginx.ingress.kubernetes.io/canary-by-header&lt;/code&gt;允许自定义标头值而不是使用硬编码值的扩展。如果&lt;code&gt;nginx.ingress.kubernetes.io/canary-by-header&lt;/code&gt;未定义注释，则没有任何效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例1：使用canary-by-header&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/canary: &amp;quot;true&amp;quot;
    nginx.ingress.kubernetes.io/canary-by-header: &amp;quot;new&amp;quot;
  labels:
    app: demo
  name: demo-ingress
  namespace: demo-canary
spec:
  rules:
  - host: canary.example.com
    http:
      paths:
      - backend:
          serviceName: demo-canary
          servicePort: 80
        path: /
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个示例，当你请求头加入new: always的时候就会访问demo-canary，当标头设置never为时，则不会访问。例如下面的这个curl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -s -H &amp;quot;new: always&amp;quot;  http://canary.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面这个示例使用的是自定义的标头值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例2：使用canary-by-header-value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/canary: &amp;quot;true&amp;quot;
    nginx.ingress.kubernetes.io/canary-by-header: &amp;quot;new&amp;quot;
    nginx.ingress.kubernetes.io/canary-by-header-value：&amp;quot;xxx&amp;quot;
  labels:
    app: demo
  name: demo-ingress
  namespace: demo-canary
spec:
  rules:
  - host: canary.example.com
    http:
      paths:
      - backend:
          serviceName: demo-canary
          servicePort: 80
        path: /
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用如下请求可以正常访问demo-canary&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -s -H &amp;quot;new: xxx&amp;quot; http://canary.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基于cookie的流量切分&#34;&gt;基于Cookie的流量切分&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nginx.ingress.kubernetes.io/canary-by-cookie：&lt;/code&gt;用于通知Ingress将请求路由到Canary Ingress中指定的服务的cookie。当cookie值设置always为时，它将被路由到Canary。当cookie被设置never为时，它将永远不会被路由到Canary。对于任何其他值，cookie将被加入，并且请求与其他Canary规则的优先级进行比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/canary: &amp;quot;true&amp;quot;
    nginx.ingress.kubernetes.io/canary-by-cookie: &amp;quot;use_under_30_feature&amp;quot;
  labels:
    app: demo
  name: demo-ingress
  namespace: demo-canary
spec:
  rules:
  - host: canary.example.com
    http:
      paths:
      - backend:
          serviceName: demo-canary
          servicePort: 80
        path: /
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的这个示例，当cookie设置为use_under_30_feature为always的时候，则会访问demo-canary&lt;/p&gt;
&lt;h2 id=&#34;基于服务权重的流量切分&#34;&gt;基于服务权重的流量切分&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;nginx.ingress.kubernetes.io/canary-weight：&lt;/code&gt;将路由到金丝雀Ingress中指定的服务的随机请求的整数（0 - 100）百分比。权重为0意味着该Canary规则不会向Canary入口中的服务发送任何请求。权重为100意味着所有请求都将被发送到Ingress中指定的替代服务。示例如下（使用20%的权重）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/canary: &amp;quot;true&amp;quot;
    nginx.ingress.kubernetes.io/canary-weight: &amp;quot;20&amp;quot;
  labels:
    app: demo
  name: demo-ingress
  namespace: demo-canary
spec:
  rules:
  - host: canary.example.com
    http:
      paths:
      - backend:
          serviceName: demo-canary
          servicePort: 80
        path: /
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里权重不是一个精确的百分比，使用过程当中，只是会看到一个近似分布。&lt;/p&gt;
&lt;h2 id=&#34;三种注释的优先级和注意点&#34;&gt;三种注释的优先级和注意点&lt;/h2&gt;
&lt;p&gt;上面的规则按优先顺序进行评估。优先顺序如下：&lt;br&gt;
&lt;code&gt;canary-by-header -&amp;gt; canary-by-cookie -&amp;gt; canary-weight&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 当您将入口标记为canary时，除了&lt;code&gt;nginx.ingress.kubernetes.io/load-balance&lt;/code&gt;和之外，所有其他非canary注释都将被忽略（从相应的主入口继承）&lt;code&gt;nginx.ingress.kubernetes.io/upstream-hash-by&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;已知的限制&lt;/strong&gt; 目前，每个Ingress规则最多可以应用一个canary入口。&lt;/p&gt;
">ingres-nginx annotations高级配置（灰度和金丝雀发布）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/UVRm22QVT/"" data-c="
          &lt;h2 id=&#34;并发用户数是指现实系统中操作业务的用户在性能测试工具中一般称为虚拟用户数virutal-user&#34;&gt;并发用户数：是指现实系统中操作业务的用户，在性能测试工具中，一般称为虚拟用户数(Virutal User)。&lt;/h2&gt;
&lt;p&gt;并发用户数和注册用户数、在线用户数的概念不同，&lt;br&gt;
1、并发用户数一定会对服务器产生压力的，&lt;br&gt;
2、而在线用户数只是 ”挂” 在系统上，对服务器不产生压力，&lt;br&gt;
3、注册用户数一般指的是数据库中存在的用户数。&lt;/p&gt;
&lt;h2 id=&#34;tpstransaction-per-second-每秒事务数-是衡量系统性能的一个非常重要的指标&#34;&gt;TPS：Transaction Per Second, 每秒事务数, 是衡量系统性能的一个非常重要的指标。&lt;/h2&gt;
&lt;p&gt;TPS就是每秒事务数，但是事务是基于虚拟用户数的，假如1个虚拟用户在1秒内完成1笔事务，那么TPS明显就是1；如果 某笔业务响应时间是1ms,那么1个用户在1秒内能完成1000笔事务，TPS就是1000了；如果某笔业务响应时间是1s,那么1个用户在1秒内只能完 成1笔事务，要想达到1000TPS，至少需要1000个用户；因此可以说1个用户可以产生1000TPS，1000个用户也可以产生1000TPS，无非是看响应时间快慢。&lt;/p&gt;
&lt;p&gt;也就是说，在评定服务器的性能时，应该结合TPS和并发用户数，以TPS为主，并发用户数为辅来衡量系统的性能。如果必须要用并发用户数来衡量的 话，需要一个前提，那就是交易在多长时间内完成，因为在系统负载不高的情况下，将思考时间(思考时间的值等于交易响应时间)加到脚本中，并发用户数基本可 以增加一倍，因此用并发用户数来衡量系统的性能没太大的意义。&lt;/p&gt;
&lt;p&gt;在性能测试时并不需要用上万的用户并发去进行测试，如果只需要保证系统处理业务时间足够快，几百个用户甚至几十个用户就可 以达到目的。据他了解，很多专家做过的性能测试项目基本都没有超过5000用户并发。因此对于大型系统、业务量非常高、硬件配置足够多的情况下，5000 用户并发就足够了；对于中小型系统，1000用户并发就足够了。&lt;/p&gt;
&lt;h2 id=&#34;系统吞吐量几个重要参数tps-并发数-响应时间&#34;&gt;系统吞吐量几个重要参数：TPS、并发数、响应时间&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;TPS：每秒钟事务数量&lt;/li&gt;
&lt;li&gt;并发数： 系统同时处理的事务数&lt;/li&gt;
&lt;li&gt;响应时间：一般取平均响应时间&lt;/li&gt;
&lt;li&gt;TPS=并发用户数 / (响应时间+Thinktime)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;并发用户如何计算&#34;&gt;并发用户如何计算&lt;/h2&gt;
&lt;h3 id=&#34;一-经典公式1&#34;&gt;一、经典公式1：&lt;/h3&gt;
&lt;p&gt;一般来说，利用以下经验公式进行估算系统的平均并发用户数和峰值数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平均并发用户数为 &lt;code&gt;C = nL/T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;并发用户数峰值&lt;code&gt; C‘ = C + 3*根号C&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C是平均并发用户数，n是login session的数量，L是login session的平均长度，T是值考察的时间长度&lt;br&gt;
C’是并发用户数峰值&lt;/p&gt;
&lt;p&gt;举例1，假设系统A，该系统有3000个用户，平均每天大概有400个用户要访问该系统（可以从系统日志从获得），对于一个典型用户来说，一天之内用户从登陆到退出的平均时间为4小时，而在一天之内，用户只有在8小时之内会使用该系统。&lt;br&gt;
那么&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  平均并发用户数为：C = 400*4/8 = 200
  并发用户数峰值为：C‘ = 200 + 3*根号200 = 243
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例2， 某公司为其170000名员工设计了一个薪酬系统，员工可进入该系统查询自己的薪酬信息，但并不是每个人都会用这个系统，假设只有50%的人会定期用改系统，这些人里面有70%是在每个月的最后一周使用一次该系统，且平均使用系统时间为5分钟。则一个月最后一周的平均并发用户数为（朝九晚五）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  n = 170000*0.5*0.7/5 = 11900
  C= 11900*5/60/8 = 124
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;吞吐量计算为：&lt;code&gt;F = Vu * R / T &lt;/code&gt;单位为个/s&lt;/p&gt;
&lt;p&gt;F为事务吞吐量，Vu为虚拟用户数个数，R为每个虚拟用户发出的请求数，T为处理这些请求所花费的时间&lt;/p&gt;
&lt;h3 id=&#34;二-通用公式2&#34;&gt;二、通用公式2：&lt;/h3&gt;
&lt;p&gt;对绝大多数场景，我们用&lt;code&gt;（用户总量/统计时间）*影响因子（一般为3）&lt;/code&gt;来进行估算并发量。&lt;/p&gt;
&lt;p&gt;比如，以乘坐地铁为例子，每天乘坐人数为5万人次，每天早高峰是7到9点，晚高峰是6到7点，根据8/2原则，80%的乘客会在高峰期间乘坐地铁，则每秒到达地铁检票口的人数为 &lt;code&gt;50000 * 80%/（3 * 60 * 60）=3.7&lt;/code&gt;，约4人/S，考虑到安检，入口关闭等因素，实际堆积在检票口的人数肯定比这个要大，假定每个人需要3秒才能进站，那实际并发应为&lt;code&gt;4人/s*3s=12&lt;/code&gt;，当然影响因子可以根据实际情况增大！&lt;/p&gt;
&lt;h3 id=&#34;三-根据pv计算公式&#34;&gt;三、根据PV计算公式：&lt;/h3&gt;
&lt;p&gt;比如一个网站，每天的PV大概1000w，根据2/8原则，我们可以认为这1000w pv的80%是在一天的9个小时内完成的（人的精力有限），那么TPS为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1000w*80%/(9*3600)=246.92个/s,取经验因子3，则并发量应为：
  246.92*3=740
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;四-根据tps估计&#34;&gt;四、根据TPS估计：&lt;/h3&gt;
&lt;p&gt;公式为 &lt;code&gt;C = (Think time + 1)*TPS&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;五-根据系统用户数计算&#34;&gt;五、根据系统用户数计算：&lt;/h3&gt;
&lt;p&gt;并发用户数 = 系统最大在线用户数的8%到12%&lt;/p&gt;
">性能测试中TPS和并发用户数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/NjkdXEU8U/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6&#34;&gt;一、安装插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E5%BD%95%E5%88%B6jmeter%E8%84%9A%E6%9C%AC&#34;&gt;二、使用插件录制jmeter脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-%E4%BD%BF%E7%94%A8%E5%BD%95%E5%88%B6%E5%A5%BD%E7%9A%84jmx%E8%84%9A%E6%9C%AC&#34;&gt;三、使用录制好的jmx脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;以前录制jmeter脚本的时候，基本都是使用jmeter的代理来进行录制的，这个录制的过程设置代理的话，可能会出现一些问题，下面就介绍一个基于chrome浏览器插件的jmeter和Selenium 录制编辑回放工具：BlazeMeter&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;一-安装插件&#34;&gt;一、安装插件&lt;/h1&gt;
&lt;p&gt;可以科学上网的话,直接打开chrome浏览器，进入谷歌商店，在搜索框内搜索BlazeMeter。如下图：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a484c1504e59630.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后谷歌浏览器右上角出现下面这个图标，则说明安装成功。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a4930e222586410.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装完成之后，需要登陆BlazeMeter，这里可以使用谷歌账户直接登陆，也可以自己注册一个。（过程可能需要科学上网）&lt;/p&gt;
&lt;h1 id=&#34;二-使用插件录制jmeter脚本&#34;&gt;二、使用插件录制jmeter脚本&lt;/h1&gt;
&lt;p&gt;1）打开你要录制的网页&lt;/p&gt;
&lt;p&gt;2）打开BlzaeMeter界面，如下图所示：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a4a92db81a67030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3）点击开始录制按钮，并在网页开始操作。录制之前可以有一些高级设置，比如过滤一些css、images、JavaScript等。&lt;/p&gt;
&lt;p&gt;4）你看到右上角的BlzaeMeter图标的数字一直变化，说明你的操作事件被录制到了。中间可以填写step来设定事务&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a4a571f46c59088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5）录制完毕后，点击 &amp;quot;.jmx&amp;quot; 导出脚本.注意：这里会要求你先登陆，然后才能够导出脚本。&lt;br&gt;
比如我录制了个http://blazedemo.com/ 的定制航班操作,录制完成后&lt;/p&gt;
&lt;p&gt;可以选择Jmeter -&amp;gt;Edit your script 来编辑和修改debug或回放你的jmx脚本内容:&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a4b464a54844223.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;6）打开Jmeter,并导入刚刚你从chrome导出的脚本，看到你刚刚录制的脚本。&lt;/p&gt;
&lt;p&gt;一切都完成，接下来就是你自己去利用Jmeter去操作啦！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在录制jmeter脚本的同时，插件也会自动录制selenium的脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整个过程，可能需要科学上网&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-使用录制好的jmx脚本&#34;&gt;三、使用录制好的jmx脚本&lt;/h1&gt;
&lt;p&gt;脚本虽然录制完成了，但是里面很多参数，我们可能需要进行一些参数化之类的。这里就需要我们用jmeter gui对脚本进行修改。&lt;br&gt;
首先打开jmeter，然后打开录制好的脚本。对其中的登陆进行参数化。&lt;/p&gt;
&lt;p&gt;jmeter一般有如下几种参数化的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法1：利用函数助手&lt;br&gt;
有些对请求参数，不需要进行特殊的校验或要求，就可以利用jmeter自带的函数助手中的随机函数，每次请求产生不同的数字或字符串，如 ${__Random(0,100,)} 或 ${__RandomString(10,qwerfghhjjjjjjjkbbbbb,)} ，方便简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法2：从文件中读取&lt;br&gt;
右击选择配置元件-&amp;gt;CSV Data Set Config，添加后，即可&lt;br&gt;
一般是，一次请求中，多个参数是有一定的逻辑对应关系，此时需要提前利用代码构造好存入txt文件中。这样，jmeter每次请求就取一行的多个字段，下一次请求就取下一行的多个字段，保证了数据的有效性。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/19/5d0a50724fd1d65789.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Allow quoted data：允许双引号内的数据作为参数，逗号分隔&lt;/p&gt;
&lt;p&gt;Recycle on EOF：循环读文件&lt;/p&gt;
&lt;p&gt;Stop thread on EOF：当不循环读文件时，结束线程，不结束则退出&lt;/p&gt;
&lt;p&gt;注意：filename路径，在window上和Linux上不一样的！！！&lt;/p&gt;
&lt;p&gt;将登陆的接口参数化之后，我们就可以开多线程进行并发测试了。&lt;/p&gt;
">BlazeMeter-- Jmeter 与 Selenium 录制编辑回放 chrome 插件工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/cpGnLA2hK/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%AE%E6%A0%87&#34;&gt;目标:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B&#34;&gt;错误示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99&#34;&gt;开始编写&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%BC%96%E5%86%99dockerignore%E6%96%87%E4%BB%B6&#34;&gt;1. 编写.dockerignore文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%AE%B9%E5%99%A8%E5%8F%AA%E8%BF%90%E8%A1%8C%E5%8D%95%E4%B8%AA%E5%BA%94%E7%94%A8&#34;&gt;2. 容器只运行单个应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%B0%86%E5%A4%9A%E4%B8%AArun%E6%8C%87%E4%BB%A4%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA&#34;&gt;3. 将多个RUN指令合并为一个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E7%9A%84%E6%A0%87%E7%AD%BE%E4%B8%8D%E8%A6%81%E7%94%A8latest&#34;&gt;4. 基础镜像的标签不要用latest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%AF%8F%E4%B8%AArun%E6%8C%87%E4%BB%A4%E5%90%8E%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E6%96%87%E4%BB%B6&#34;&gt;5. 每个RUN指令后删除多余文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8Falpine%E7%89%88%E6%9C%AC%E6%9C%80%E5%A5%BD&#34;&gt;6. 选择合适的基础镜像(alpine版本最好)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E8%AE%BE%E7%BD%AEworkdir%E5%92%8C-cmd&#34;&gt;7. 设置WORKDIR和 CMD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E4%BD%BF%E7%94%A8entrypoint-%E5%8F%AF%E9%80%89&#34;&gt;8. 使用ENTRYPOINT (可选)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-%E5%9C%A8entrypoint%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8exec&#34;&gt;9. 在entrypoint脚本中使用exec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10-copy%E4%B8%8Eadd%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%89%8D%E8%80%85&#34;&gt;10. COPY与ADD优先使用前者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E5%90%88%E7%90%86%E8%B0%83%E6%95%B4copy%E4%B8%8Erun%E7%9A%84%E9%A1%BA%E5%BA%8F&#34;&gt;11. 合理调整COPY与RUN的顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8D%B7&#34;&gt;12. 设置默认的环境变量，映射端口和数据卷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E4%BD%BF%E7%94%A8label%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E5%85%83%E6%95%B0%E6%8D%AE&#34;&gt;13. 使用LABEL设置镜像元数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%E6%B7%BB%E5%8A%A0healthcheck&#34;&gt;14. 添加HEALTHCHECK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
Dockerfile的语法非常简单，然而如何加快镜像构建速度，如何减少Docker镜像的大小却不是那么直观，需要积累实践经验。这篇博客可以帮助你快速掌握编写Dockerfile的技巧。&lt;br&gt;
我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的Dockerfile。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;目标&#34;&gt;目标:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;更快的构建速度&lt;/li&gt;
&lt;li&gt;更小的Docker镜像大小&lt;/li&gt;
&lt;li&gt;更少的Docker镜像层&lt;/li&gt;
&lt;li&gt;充分利用镜像缓存&lt;/li&gt;
&lt;li&gt;增加Dockerfile可读性&lt;/li&gt;
&lt;li&gt;让Docker容器使用起来更简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;错误示例&#34;&gt;错误示例&lt;/h2&gt;
&lt;p&gt;示例Dockerfile犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用Docker运行一个Node.js应用，下面就是它的Dockerfile(CMD指令太复杂了，所以我简化了，它是错误的，仅供参考)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu
ADD . /app
RUN apt-get update
RUN apt-get upgrade -y
RUN apt-get install -y nodejs ssh mysql
RUN cd /app &amp;amp;&amp;amp; npm install
# this should start three processes, mysql and ssh
# in the background and node app in foreground
# isn&#39;t it beautifully terrible? &amp;lt;3
CMD mysql &amp;amp; sshd &amp;amp; npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开始编写&#34;&gt;开始编写&lt;/h2&gt;
&lt;h3 id=&#34;1-编写dockerignore文件&#34;&gt;1. 编写.dockerignore文件&lt;/h3&gt;
&lt;p&gt;构建镜像时，Docker需要先准备context ，将所有需要的文件收集到进程中。默认的context包含Dockerfile目录中的所有文件，但是实际上，我们并不需要.git目录，node_modules目录等内容。 .dockerignore 的作用和语法类似于 .gitignore，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.git/
node_modules/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-容器只运行单个应用&#34;&gt;2. 容器只运行单个应用&lt;/h3&gt;
&lt;p&gt;从技术角度讲，你可以在Docker容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor都运行在同一个Docker容器中。但是，这会让你非常痛苦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非常长的构建时间(修改前端之后，整个后端也需要重新构建)&lt;/li&gt;
&lt;li&gt;非常大的镜像大小&lt;/li&gt;
&lt;li&gt;多个应用的日志难以处理(不能直接使用stdout，否则多个应用的日志会混合到一起)&lt;/li&gt;
&lt;li&gt;横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)&lt;/li&gt;
&lt;li&gt;僵尸进程问题 - 你需要选择合适的init进程&lt;br&gt;
因此，我建议大家为每个应用构建单独的Docker镜像，然后使用 Docker Compose 运行多个Docker容器。&lt;br&gt;
现在，我从Dockerfile中删除一些不需要的安装包，另外，SSH可以用docker exec替代。示例如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu
ADD . /app
RUN apt-get update
RUN apt-get upgrade -y
# we should remove ssh and mysql, and use
# separate container for database
RUN apt-get install -y nodejs # ssh mysql
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-将多个run指令合并为一个&#34;&gt;3. 将多个RUN指令合并为一个&lt;/h3&gt;
&lt;p&gt;Docker镜像是分层的，下面这些知识点非常重要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dockerfile中的每个指令都会创建一个新的镜像层。&lt;/li&gt;
&lt;li&gt;镜像层将被缓存和复用&lt;/li&gt;
&lt;li&gt;当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效&lt;/li&gt;
&lt;li&gt;某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效&lt;/li&gt;
&lt;li&gt;镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。&lt;br&gt;
现在，我们将所有的RUN指令合并为一个。同时把apt-get upgrade删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu
ADD . /app
RUN apt-get update \
&amp;amp;&amp;amp; apt-get install -y nodejs \
&amp;amp;&amp;amp; cd /app \
&amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记住一点，我们只能将变化频率一样的指令合并在一起。将node.js安装与npm模块安装放在一起的话，则每次修改源代码，都需要重新安装node.js，这显然不合适。因此，正确的写法是这样的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y nodejs
ADD . /app
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-基础镜像的标签不要用latest&#34;&gt;4. 基础镜像的标签不要用latest&lt;/h3&gt;
&lt;p&gt;当镜像没有指定标签时，将默认使用latest 标签。因此， FROM ubuntu 指令等同于FROM ubuntu:latest。当时，当镜像更新时，latest标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用latest标签，否则的话，最好指定确定的镜像标签。&lt;br&gt;
示例Dockerfile应该使用16.04作为标签。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:16.04 # it&#39;s that easy!
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y nodejs
ADD . /app
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-每个run指令后删除多余文件&#34;&gt;5. 每个RUN指令后删除多余文件&lt;/h3&gt;
&lt;p&gt;假设我们更新了apt-get源，下载，解压并安装了一些软件包，它们都保存在/var/lib/apt/lists/目录中。但是，运行应用时Docker镜像中并不需要这些文件。我们最好将它们删除，因为它会使Docker镜像变大。&lt;br&gt;
示例Dockerfile中，我们可以删除/var/lib/apt/lists/目录中的文件(它们是由apt-get update生成的)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:16.04
RUN apt-get update \
&amp;amp;&amp;amp; apt-get install -y nodejs \
# added lines
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
ADD . /app
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-选择合适的基础镜像alpine版本最好&#34;&gt;6. 选择合适的基础镜像(alpine版本最好)&lt;/h3&gt;
&lt;p&gt;在示例中，我们选择了ubuntu作为基础镜像。但是我们只需要运行node程序，有必要使用一个通用的基础镜像吗？node镜像应该是更好的选择。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node
ADD . /app
# we don&#39;t need to install node
# anymore and use apt-get
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更好的选择是alpine版本的node镜像。alpine是一个极小化的Linux发行版，只有4MB，这让它非常适合作为基础镜像。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine
ADD . /app
RUN cd /app &amp;amp;&amp;amp; npm install
CMD npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;7-设置workdir和-cmd&#34;&gt;7. 设置WORKDIR和 CMD&lt;/h3&gt;
&lt;p&gt;WORKDIR指令可以设置默认目录，也就是运行RUN / CMD / ENTRYPOINT指令的地方。&lt;br&gt;
CMD指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考官方文档)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine
WORKDIR /app
ADD . /app
RUN npm install
CMD [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8-使用entrypoint-可选&#34;&gt;8. 使用ENTRYPOINT (可选)&lt;/h3&gt;
&lt;p&gt;ENTRYPOINT指令并不是必须的，因为它会增加复杂度。ENTRYPOINT是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的Docker镜像。entrypoint.sh如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env sh
# $0 is a script name,
# $1, $2, $3 etc are passed arguments
# $1 is our command
CMD=$1
case &amp;quot;$CMD&amp;quot; in
&amp;quot;dev&amp;quot; )
npm install
export NODE_ENV=development
exec npm run dev
;;
&amp;quot;start&amp;quot; )
# we can modify files here, using ENV variables passed in
# &amp;quot;docker create&amp;quot; command. It can&#39;t be done during build process.
echo &amp;quot;db: $DATABASE_ADDRESS&amp;quot; &amp;gt;&amp;gt; /app/config.yml
export NODE_ENV=production
exec npm start
;;
* )
# Run custom command. Thanks to this line we can still use
# &amp;quot;docker run our_image /bin/bash&amp;quot; and it will work
exec $CMD ${@:2}
;;
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例Dockerfile:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine

WORKDIR /app

ADD . /app
RUN npm install

ENTRYPOINT [&amp;quot;./entrypoint.sh&amp;quot;]
CMD [&amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用如下命令运行该镜像:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 运行开发版本
docker run our-app dev
# 运行生产版本
docker run our-app start
# 运行bash
docker run -it our-app /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用了entrypoint后，我们就可以在docker运行的命令后面接上参数，来实现不同情况的运行。&lt;/p&gt;
&lt;h3 id=&#34;9-在entrypoint脚本中使用exec&#34;&gt;9. 在entrypoint脚本中使用exec&lt;/h3&gt;
&lt;p&gt;在前文的entrypoint脚本中，我使用了exec命令运行node应用。不使用exec的话，我们则不能顺利地关闭容器，因为SIGTERM信号会被bash脚本进程吞没。exec命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。&lt;/p&gt;
&lt;h3 id=&#34;10-copy与add优先使用前者&#34;&gt;10. COPY与ADD优先使用前者&lt;/h3&gt;
&lt;p&gt;COPY指令非常简单，仅用于将文件拷贝到镜像中。ADD相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考官方文档)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine

WORKDIR /app
COPY . /app
RUN npm install

ENTRYPOINT [&amp;quot;./entrypoint.sh&amp;quot;]
CMD [&amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-合理调整copy与run的顺序&#34;&gt;11. 合理调整COPY与RUN的顺序&lt;/h3&gt;
&lt;p&gt;我们应该把变化最少的部分放在Dockerfile的前面，这样可以充分利用镜像缓存。&lt;br&gt;
示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine

WORKDIR /app

COPY package.json /app
RUN npm install
COPY . /app

ENTRYPOINT [&amp;quot;./entrypoint.sh&amp;quot;]
CMD [&amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-设置默认的环境变量映射端口和数据卷&#34;&gt;12. 设置默认的环境变量，映射端口和数据卷&lt;/h3&gt;
&lt;p&gt;运行Docker容器时很可能需要一些环境变量。在Dockerfile设置默认的环境变量是一种很好的方式。另外，我们应该在Dockerfile中设置映射端口和数据卷。示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine

ENV PROJECT_DIR=/app

WORKDIR $PROJECT_DIR

COPY package.json $PROJECT_DIR
RUN npm install
COPY . $PROJECT_DIR

ENV MEDIA_DIR=/media \
NODE_ENV=production \
APP_PORT=3000

VOLUME $MEDIA_DIR
EXPOSE $APP_PORT

ENTRYPOINT [&amp;quot;./entrypoint.sh&amp;quot;]
CMD [&amp;quot;start&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ENV指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用ARG指令。&lt;/p&gt;
&lt;h3 id=&#34;13-使用label设置镜像元数据&#34;&gt;13. 使用LABEL设置镜像元数据&lt;/h3&gt;
&lt;p&gt;使用LABEL指令，可以为镜像设置元数据，例如镜像创建者或者镜像说明。旧版的Dockerfile语法使用MAINTAINER指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如nvidia-docker需要用到com.nvidia.volumes.needed。示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine
LABEL maintainer &amp;quot;jakub.skalecki@example.com&amp;quot;
...

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-添加healthcheck&#34;&gt;14. 添加HEALTHCHECK&lt;/h3&gt;
&lt;p&gt;运行容器时，可以指定--restart always选项。这样的话，容器崩溃时，Docker守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用HEALTHCHECK指令可以让Docker周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回0，否则返回1。对HEALTHCHECK感兴趣的话，可以参考&lt;a href=&#34;https://blog.newrelic.com/engineering/docker-health-check-instruction/&#34;&gt;这篇博客&lt;/a&gt;。示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:7-alpine
LABEL maintainer &amp;quot;jakub.skalecki@example.com&amp;quot;

ENV PROJECT_DIR=/app
WORKDIR $PROJECT_DIR

COPY package.json $PROJECT_DIR
RUN npm install
COPY . $PROJECT_DIR

ENV MEDIA_DIR=/media \
NODE_ENV=production \
APP_PORT=3000

VOLUME $MEDIA_DIR
EXPOSE $APP_PORT
HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1

ENTRYPOINT [&amp;quot;./entrypoint.sh&amp;quot;]
CMD [&amp;quot;start&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;
">如何编写最佳的Dockerfile</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/xChmFhWoQ/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#rancher%E4%BB%8B%E7%BB%8D&#34;&gt;Rancher介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rancher-%E7%9A%84%E7%89%B9%E8%89%B2&#34;&gt;Rancher 的特色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2rancher-server%E5%8D%95%E8%8A%82%E7%82%B9&#34;&gt;部署Rancher server单节点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2rancher-agent%E8%8A%82%E7%82%B9&#34;&gt;部署Rancher agent节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AErancher&#34;&gt;配置Rancher&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%80%E5%90%AF%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7&#34;&gt;开启集群监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97&#34;&gt;配置应用商店&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8&#34;&gt;创建一个应用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%8E%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E4%B8%AD%E5%88%9B%E5%BB%BA&#34;&gt;从应用商店中创建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8&#34;&gt;手动创建自己的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;rancher介绍&#34;&gt;Rancher介绍&lt;/h1&gt;
&lt;p&gt;Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;简单的说，就是一个可以让你通过 web 界面管理 docker 容器的平台。定位上和 K8s 比较接近，都是通过 web 界面赋予完全的 docker 服务编排功能。&lt;/p&gt;
&lt;h1 id=&#34;rancher-的特色&#34;&gt;Rancher 的特色&lt;/h1&gt;
&lt;p&gt;能够做到这么流行，总归有几板斧头的。rancher 的几个比较突出的点有：&lt;/p&gt;
&lt;p&gt;平台部署方便。管理 docker 的平台本身也基于 docker 部署。只要你有 docker ，一句命令就完成平台的部署了。&lt;/p&gt;
&lt;p&gt;平台扩展方便。通过 agent 机制，一句 docker 命令完成 agent 部署，快速增加你的物理机。同时也支持 AWS 等云主机， 2.0 版本甚至还支持 K8s 。&lt;/p&gt;
&lt;p&gt;服务部署方便。通过应用商店，2步完成应用部署，而且还是像 docker-compose 那样各个中间件独立编排，可以随时扩容的哦。&lt;/p&gt;
&lt;p&gt;自带账户权限。相比 K8s 没有账号管理，rancher 自带账号权限体系。账号可以独立创建，也可以很方便地接入 ldap 等账号体系。对于公司使用是一大利器。&lt;/p&gt;
&lt;h1 id=&#34;部署rancher-server单节点&#34;&gt;部署Rancher server单节点&lt;/h1&gt;
&lt;p&gt;安装环境:&lt;br&gt;
三台centos7 虚拟机，都安装好docker&lt;/p&gt;
&lt;p&gt;下面介绍三种不同证书情况下的安装方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用自签证书&lt;/strong&gt;&lt;br&gt;
安装rancher(包括持久化和支持本机部署，自签证书)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --restart=unless-stopped \
  -p 8080:80 -p 8443:443 \
  -v /root/rancher:/var/lib/rancher \
  rancher/rancher:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用自有证书部署&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --restart=unless-stopped \
	-p 80:80 -p 443:443 \
	-v /root/ssl/certificate.pem:/etc/rancher/ssl/cert.pem \
	-v /root/ssl/key.pem:/etc/rancher/ssl/key.pem \
  -v /root/rancher:/var/lib/rancher \
	rancher/rancher:latest --no-cacerts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用acme自动证书部署&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  -v /root/rancher:/var/lib/rancher \
  rancher/rancher:latest \
  --acme-domain asoco.ac.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps:如果需要挂载外部数据库，可以加如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-v &amp;lt;host_vol&amp;gt;:/var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多部署方式可以参考&lt;a href=&#34;https://rancher.com/docs/rancher/v1.6/zh/installing-rancher/installing-server/#single-container-bind-mount&#34;&gt;官方部署文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;部署rancher-agent节点&#34;&gt;部署Rancher agent节点&lt;/h2&gt;
&lt;p&gt;首先我们先添加一个集群，点击添加集群按钮后，可以看到如下图：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc564f27ea98.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;Rancher可以添加来自云服务商提供的k8s集群，支持阿里云、谷歌云、微软云等。也可以添加自己本地的集群，就是红色方框的这个选项。本次我们在自己的虚拟机上添加k8s集群。注意，这里并不需要你得虚拟机上先装好k8s集群，Rancher会自动帮你安装，只需要虚拟机上正常安装好了docker即可。&lt;/p&gt;
&lt;p&gt;下面的集群选项，选择v1.13.5-rancher1-2，然后网络组件选择Canal，云提供商就选择无。当然这里的配置也可以根据实际情况进行修改。选完之后点击下一步。&lt;/p&gt;
&lt;p&gt;点击下一步后我们可以看到一个自定义选项，选择我们的节点机是什么角色。这里我们全选。选择完成之后，再复制下面自动生成的命令。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.2 --server https://192.168.1.22:8443 --token 4rrw6844ztxdqsss9qjmf9np --ca-checksum b68bdaad339 --worker --etcd --controlplane
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个人生成的命令都不一样，不能直接复制我的命令使用。复制完命令即可再刚才的节点机中，直接运行该命令即可，会自动帮我们安装k8s集群，并且配置好对应的角色。&lt;/p&gt;
&lt;p&gt;等待大约10分钟这样，agent主机即可安装完成。&lt;/p&gt;
&lt;p&gt;然后我们就可以在集群界面看到集群的相关信息，如下图。这里我是启用了集群监控，所以多了一个grafana。&lt;/p&gt;
&lt;p&gt;集群总览&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc56703d38d3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;主机总览&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc56758be6eb.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;配置rancher&#34;&gt;配置Rancher&lt;/h2&gt;
&lt;p&gt;安装完成之后，打开rancher，首次登陆需要设置admin账户的密码，设置完成之后，就可以看到rancher的管理界面了。然后我们需要添加集群和agent节点&lt;/p&gt;
&lt;h3 id=&#34;开启集群监控&#34;&gt;开启集群监控&lt;/h3&gt;
&lt;p&gt;点击集群后，在上面选择工具→监控。点击启用监控，配置对应的选项后，保存即可自动启动集群级别的监控。这里的配置如果不修改，直接启用也是可以的。&lt;br&gt;
集群监控配置：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc567d6305d0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;等待几分钟后，监控服务就启动好了，然后在刚才的集群界面就可以看到整个集群的性能监控指标。&lt;/p&gt;
&lt;p&gt;除此之外，我们还可以开启单个项目组的监控。点开一个项目，然后再工具--监控中启用监控。&lt;/p&gt;
&lt;p&gt;这样所有的监控就已经启动了，我可以监控每一个pod、容器（包括已经删除的容器）的CPU、内存、网络io数据。&lt;/p&gt;
&lt;p&gt;我们可以点开一个pod或者直接查看集群的grafana，来查看性能数据大盘。如下图所示：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/06/20/5d0aecb3b204775292.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置应用商店&#34;&gt;配置应用商店&lt;/h3&gt;
&lt;p&gt;Rancher本身就自带了应用商店，但是应用数量非常的少。但是Rancher本身是支持Helm仓库的配置的，所以我们可以添加一些Helm仓库来增加应用。当前也可以添加自有的Helm仓库&lt;/p&gt;
&lt;p&gt;这里我选择添加微软的Helm仓库&lt;br&gt;
在应用商店的选项中，点击添加应用商店，如下图：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc568acaebee.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
名字随便取一个，比如azure&lt;br&gt;
地址填写为&lt;code&gt;http://mirror.azure.cn/kubernetes/charts/&lt;/code&gt;&lt;br&gt;
然后点出创建，等带同步数据后，就可以在应用商店看到多出来的应用了。&lt;/p&gt;
&lt;h1 id=&#34;创建一个应用&#34;&gt;创建一个应用&lt;/h1&gt;
&lt;h2 id=&#34;从应用商店中创建&#34;&gt;从应用商店中创建&lt;/h2&gt;
&lt;p&gt;选择刚才创建好的集群，然后选择默认的空间。点击应用商店，然后点击启动。&lt;br&gt;
在默认的商店library中，我们可以找到mysql选项，然后点击查看详情。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/30/5cc7f29c5df0a.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图，再这里我们可以配置很多选项，比如mysql的用户名、密码、端口等，这里就不做详细介绍了。&lt;/p&gt;
&lt;p&gt;点击启动，然后就可以看到再默认的命名空间中，启动了一个容器。第一次会需要下载容器镜像，所以需要等待一段时间，完成后，我们可以看到状态显示为active（如下图）。然后我们可以用navicat访问下设置的端口，进入mysql。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/30/5cc7f34859355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;到此应用就正式创建完成了。&lt;/p&gt;
&lt;h2 id=&#34;手动创建自己的应用&#34;&gt;手动创建自己的应用&lt;/h2&gt;
&lt;p&gt;大部分的时候，应用商店里面的应用不符合我们的要求，需要自己手动创建。这里同样，选择默认的命名空间，再选择工作负载，然后点击部署服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/30/5cc7f48ec62a0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里还是以mysql服务为例，我们部署一个mysql服务。所以镜像部分填写的是mysql:5.7.14 。&lt;/p&gt;
&lt;p&gt;然后下面的环境变量配置中，可以像使用docker容器一样，配置环境变量。例如我们直接docker安装mysql的时候运行的命令是&lt;code&gt;docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -d mysql:5.7 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中-e 参数就是环境变量，所以我们就可以再环境变量中填写变量为&lt;code&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt; ，值为&lt;code&gt;123456&lt;/code&gt; 。&lt;br&gt;
然后-v参数就是挂载数据卷，那么再数据卷中，就可以一样的配置挂载目录，达到持久化的目的。&lt;/p&gt;
&lt;p&gt;由于k8s的集群特性，所以这还有主机调度策略和缩放升级策略，健康检查。这里不过多介绍，可以自己去摸索，而且都是中文汉化，应该很好理解。&lt;/p&gt;
&lt;p&gt;最后点击启动，然后等待容器状态变成active即可。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;Rancher提供了一个很好的容器管理平台，使得我们可以轻松的借助该平台管理k8s集群和创建k8s集群服务。另外还有cli可以接入持续集成，实现自动部署等功能。此外Rancher还有集群报警、日志管理等多个功能，支持企业微信的报警推送。&lt;/p&gt;
">使用Rancher快速搭建一个k8s集群</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/y2zW26NMV/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AFkubernetes&#34;&gt;什么是Kubernetes？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#k8s-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D&#34;&gt;k8s 核心概念介绍&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%86%E7%BE%A4&#34;&gt;集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pod&#34;&gt;Pod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lable&#34;&gt;Lable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#service&#34;&gt;Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#node&#34;&gt;Node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kubernetes-master&#34;&gt;Kubernetes Master&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;什么是kubernetes&#34;&gt;什么是Kubernetes？&lt;/h1&gt;
&lt;p&gt;Kubernetes（k8s）是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展。如果你曾经用过Docker容器技术部署容器，那么可以将Docker看成Kubernetes内部使用的低级别组件。Kubernetes不仅仅支持Docker，还支持Rocket，这是另一种容器技术。使用Kubernetes可以：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;自动化容器的部署和复制&lt;/li&gt;
&lt;li&gt;随时扩展或收缩容器规模&lt;/li&gt;
&lt;li&gt;将容器组织成组，并且提供容器间的负载均衡&lt;/li&gt;
&lt;li&gt;很容易地升级应用程序容器的新版本&lt;/li&gt;
&lt;li&gt;提供容器弹性，如果容器失效就替换它，等等...&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;k8s-核心概念介绍&#34;&gt;k8s 核心概念介绍&lt;/h1&gt;
&lt;h2 id=&#34;集群&#34;&gt;集群&lt;/h2&gt;
&lt;p&gt;集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。这里可以看到一个典型的Kubernetes架构图。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/28/5cc55a565df19.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图可以看到如下组件，使用特别的图标表示Service和Label：&lt;br&gt;
Pod&lt;br&gt;
Container（容器）&lt;br&gt;
Label（标签）&lt;br&gt;
Replication Controller（复制控制器）&lt;br&gt;
Service（服务）&lt;br&gt;
Node（节点）&lt;br&gt;
Kubernetes Master（Kubernetes主节点）&lt;/p&gt;
&lt;h2 id=&#34;pod&#34;&gt;Pod&lt;/h2&gt;
&lt;p&gt;Pod（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：&lt;br&gt;
如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持卷的概念，因此可以使用持久化的卷类型。&lt;br&gt;
是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。&lt;br&gt;
如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。&lt;/p&gt;
&lt;h2 id=&#34;lable&#34;&gt;Lable&lt;/h2&gt;
&lt;p&gt;正如图所示，一些Pod有Label 。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个&amp;quot;tier&amp;quot;和“app”标签，通过Label（tier=frontend, app=myapp）来标记前端Pod容器，使用Label（tier=backend, app=myapp）标记后台Pod。然后可以使用Selectors选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。&lt;/p&gt;
&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;
&lt;p&gt;如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？&lt;/p&gt;
&lt;p&gt;Service是定义一系列Pod以及访问这些Pod的策略的一层抽象。Service通过Label找到Pod组。因为Service是抽象的，所以在图表里通常看不到它们的存在，这也就让这一概念更难以理解。&lt;/p&gt;
&lt;p&gt;现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，lable选择器为（tier=backend, app=myapp）。backend-service 的Service会完成如下两件重要的事情：&lt;br&gt;
会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。&lt;br&gt;
现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。这里有更多技术细节。&lt;/p&gt;
&lt;p&gt;下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。&lt;br&gt;
&lt;img src=&#34;http://dockone.io/uploads/article/20151230/125bbccce0b3bbf42abab0e520d9250b.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;node&#34;&gt;Node&lt;/h2&gt;
&lt;p&gt;节点（上图橘色方框）是物理或者虚拟机器，作为Kubernetes worker，通常称为Minion。每个节点都运行如下Kubernetes关键组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubelet：是主节点代理。&lt;/li&gt;
&lt;li&gt;Kube-proxy：Service使用其将链接路由到Pod，如上文所述。&lt;/li&gt;
&lt;li&gt;Docker或Rocket：Kubernetes使用的容器技术来创建容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubernetes-master&#34;&gt;Kubernetes Master&lt;/h2&gt;
&lt;p&gt;集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。&lt;/p&gt;
">Kubernetes简单介绍和核心概念</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/0NMEHvaef/"" data-c="
          &lt;p&gt;CI和CD是现在开发、测试、运维必不可少的工作流程&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;主流-cicd-应用&#34;&gt;主流 CI/CD 应用&lt;/h1&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E6%B5%81-cicd-%E5%BA%94%E7%94%A8&#34;&gt;主流 CI/CD 应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%80%E6%AC%A1%E8%A7%84%E8%8C%83%E7%9A%84%E5%8F%91%E5%B8%83%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9&#34;&gt;容器环境下一次规范的发布应该包含哪些内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ci-%E6%B5%81%E7%A8%8B%E6%BC%94%E7%A4%BA&#34;&gt;CI 流程演示&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E4%BA%BA%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F&#34;&gt;单人开发模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F&#34;&gt;多人开发模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gitflow-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F&#34;&gt;GitFlow 开发模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#step-by-step-%E6%9E%84%E5%BB%BA-ci-%E5%B7%A5%E4%BD%9C%E6%B5%81&#34;&gt;Step by Step 构建 CI 工作流&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#step0-%E5%9F%BA%E4%BA%8E-docker-%E9%83%A8%E7%BD%B2-jenkins&#34;&gt;Step.0: 基于 docker 部署 Jenkins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#step1-%E5%8D%95%E4%BA%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E-docker-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA&#34;&gt;Step.1: 单人工作流，自动化单元测试与 Docker 镜像构建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#step2-gitflow-%E5%A4%9A%E5%88%86%E6%94%AF%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C%E6%B5%81&#34;&gt;Step.2: GitFlow 多分支团队工作流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#step3-%E8%AF%AD%E4%B9%89%E5%8C%96%E5%8F%91%E5%B8%83&#34;&gt;Step.3: 语义化发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%8E%E8%AF%9D&#34;&gt;后话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;对比经过一些比较和调研，由于团队主要使用java语言开发，最终选择了 Jenkins作为主力 CI 工具。&lt;br&gt;
下面这张表总结了主流的几个 CI/CD 应用的特点&lt;/p&gt;
&lt;p&gt;项目名称 | 开发语言 | 配置语言 | 公有云服务 | 私有部署 | 备注&lt;br&gt;
--------|-------|--------|----------|--------|------|--------&lt;br&gt;
Travis CI | Ruby | YAML | 有 | 不支持 | 公共项目免费,私有项目 $69/单进程, $129/2 进程&lt;br&gt;
Circle CI | Clojure | YAML | 有 | 不支持 | 单进程免费，$50/加 1 进程&lt;br&gt;
Gitlab CI | Ruby | YAML | 有| 支持 | 绑定 Gitlab 代码管理&lt;br&gt;
Jenkins | Java | Groovy/YAML | 无| 支持 | 最新版本支持pipeline文件&lt;br&gt;
Drone | Go | YAML | 有 | 支持 | Cloud 版本不支持私有项目，自建版本无此限制&lt;/p&gt;
&lt;p&gt;Travis CI 和 CircleCI 是目前&lt;a href=&#34;https://www.datanyze.com/market-share/ci/jenkins-market-share&#34;&gt;占有率最高的两个公有云 CI&lt;/a&gt;，易用性上相差无几，只是收费方式有差异。由于不支持私有部署，如果并行的任务量一大，按进程收费其实并不划算；而且由于服务器位置的原因，如果推送镜像到国内，速度很不理想。&lt;br&gt;
Gitlab CI 虽然好用，和 Gitlab 是深度绑定的，但是由于我们需要多个环境的部署持续集成部署，gitlab-ci并不能很好的做到这一点。&lt;br&gt;
Jenkins 作为老牌劲旅，也是目前市场占有率最高的 CI，几乎可以覆盖所有 CI 的使用场景，由于使用 Java 编写，配置文件使用 Groovy 语法，非常适合 Java 为主语言的团队。Jenkins 显然是可以满足我们需要的，目前也有 了使用 YAML 书写 CI 配置，所以最终选择了 Jenkins 。&lt;br&gt;
Drone是新兴技术，使用了go语言开发，结合各种插件，使用起来也很方便，但是考虑到本文发布的时候Drone才刚刚发布1.0的正式版，所以Drone仅为考虑的对象。待以后成熟了，再使用。&lt;/p&gt;
&lt;h1 id=&#34;容器环境下一次规范的发布应该包含哪些内容&#34;&gt;容器环境下一次规范的发布应该包含哪些内容&lt;/h1&gt;
&lt;p&gt;技术选型完成后，我想首先演示一下最终的成果，希望能直观的体现出 CI 对自动化效率起到的提升，不过这就涉及到一个问题：在容器环境下，一次发布应该包含哪些内容，其中有哪些部分是可以被 CI 自动化完成的。这个问题虽然每家公司各不相同，不过按经验来说，容器环境下一次版本发布通常包含这样一个 Checklist：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* [ ] 代码的下载构建及编译
* [ ] 运行单元测试，生成单元测试报告及覆盖率报告等
* [ ] 在测试环境对当前版本进行测试
* [ ] 为待发布的代码打上版本号
* [ ] 编写 ChangeLog 说明当前版本所涉及的修改
* [ ] 构建 Docker 镜像
* [ ] 将 Docker 镜像推送到镜像仓库
* [ ] 在预发布环境测试当前版本
* [ ] 正式发布到生产环境
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看上去很繁琐对吗，如果每次发布都需要人工去处理上述的所有内容，不仅容易出错，而且也无法应对 DevOps 时代一天至少数次的发布频率，那么下面就来使用 CI 来解决所有问题吧。&lt;/p&gt;
&lt;h1 id=&#34;ci-流程演示&#34;&gt;CI 流程演示&lt;/h1&gt;
&lt;p&gt;为了对 CI 流程有最直观的认识，可以创建一个spring boot demo演示完整的流程，项目自动构建的 Docker 镜像会推送到 docker registry ，。为了方便说明，假设这个项目的核心文件只有一个jar包服务。&lt;/p&gt;
&lt;h2 id=&#34;单人开发模式&#34;&gt;单人开发模式&lt;/h2&gt;
&lt;p&gt;目前这个项目背后的 CI 都已经配置部署好，假设我是这个项目的唯一开发人员，如何开发一个新功能并发布新版本呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. Clone 项目到本地， 修改项目代码， 如将 Hello World 改为 Hello World V2。
2. git add .，然后书写符合约定的 Commit 并提交代码， git commit -m &amp;quot;feature: hello world v2”
3. 推送代码到代码库git push，等待数分钟后，开发人员会看到单元测试结果，gitlab仓库会产生一次新版本的 release，release 内容为当前版本的 ChangeLog， 同时线上已经完成了新功能的发布。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然在开发者看来，一次发布简单到只需 3 个指令，但背后经过了如下的若干次交互，这是一次发布实际产生交互的时序图，具体每个环节如何工作将在后文中详细说明。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/13/5cb0bb9a7e64f.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;多人开发模式&#34;&gt;多人开发模式&lt;/h2&gt;
&lt;p&gt;一个项目一般不止一个开发人员，比如我是新加入这个项目的成员，在这个 Demo 中应该如何上线新功能呢？同样非常简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Clone 项目到本地，创建一个分支来完成新功能的开发, git checkout -b feature/hello-world-v3。在这个分支修改一些代码，比如将Hello World V2修改为Hello World V3
2.  git add .书写符合规范的 Commit 并提交代码， git commit -m &amp;quot;feature: hello world v3”
3.  将代码推送到代码库的对应分支， git push origin feature/hello-world
4.  如果功能已经开发完毕，可以向 Master 分支发起一个 Pull Request，并让项目的负责人 Code Review
5.  Review 通过后，项目负责人将分支合并入主干，gitlab 仓库会产生一次新版本的 release，同时线上已经完成了新功能的发布。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个流程相比单人开发来多了 2 个环节，很适用于小团队合作，不仅强制加入了 Code Review 把控代码质量，同时也避免新人的不规范行为对发布带来影响。实际项目中，可以在 gitlab 的设置界面对 master 分支设置写入保护，这样就从根本上杜绝了误操作的可能。当然如果团队中都是熟手，就无需如此谨慎，每个人都可以负责 PR 的合并，从而进一步提升效率。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/13/5cb0bbc6f0e8f.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;gitflow-开发模式&#34;&gt;GitFlow 开发模式&lt;/h2&gt;
&lt;p&gt;在更大的项目中，参与的角色更多，一般会有开发、测试、运维几种角色的划分；还会划分出开发环境、测试环境、预发布环境、生产环境等用于代码的验证和测试；同时还会有多个功能会在同一时间并行开发。可想而知 CI 的流程也会进一步复杂。&lt;br&gt;
能比较好应对这种复杂性的，首选 &lt;a href=&#34;https://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;GitFlow 工作流&lt;/a&gt;， 即通过并行两个长期分支的方式规范代码的提交。而如果使用了 gitlab，由于有非常好用的 Pull Request 功能，可以将 GitFlow 进行一定程度的简化，最终有这样的工作流：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/04/13/5cb0bc0f96e5f.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;* 以 dev 为主开发分支，master 为发布分支
* 开发人员始终从 dev 创建自己的分支，如 feature-a
* feature-a 开发完毕后创建 PR 到 dev 分支，并进行 code review
* review 后 feature-a 的新功能被合并入 dev，如有多个并行功能亦然
* 待当前开发周期内所有功能都合并入 dev 后，从 dev 创建 PR 到 master
* dev 合并入 master，并创建一个新的 release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述是从 Git 分支角度看代码仓库发生的变化，实际在开发人员视角里，工作流程是怎样的呢。假设我是项目的一名开发人员，今天开始一期新功能的开发：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  Clone 项目到本地，git checkout dev。从 dev 创建一个分支来完成新功能的开发，git checkout -b feature/feature-a。在这个分支修改一些代码，比如将Hello World V3修改为Hello World Feature A
2.  git add .书写符合规范的 Commit 并提交代码，git commit -m &amp;quot;feature: hello world feature A&amp;quot;
3.  将代码推送到代码库的对应分支，git push origin feature/feature-a:feature/feature-a
4.  由于分支是以feature/命名的，因此 CI 会运行单元测试，并自动构建一个当前分支的镜像，发布到测试环境，并自动配置一个当前分支的域名如 test-featue-a.fs.com
5.  联系产品及测试同学在测试环境验证并完善新功能
6.  功能通过验收后发起 PR 到 dev 分支，由 Leader 进行 code review
7.  Code Review 通过后，Leader 合并当前 PR，此时 CI 会运行单元测试，构建镜像，并发布到测试环境
8.  此时 dev 分支有可能已经积累了若干个功能，可以访问测试环境对应 dev 分支的域名，如 test.fs.com，进行集成测试。
9.  集成测试完成后，由运维同学从 Dev 发起一个 PR 到 Master 分支，此时会 CI 会运行单元测试，构建镜像，并发布到预发布环境
10.  测试人员在预发布环境下再次验证功能，团队做上线前的其他准备工作
11.  运维同学合并 PR，CI 将为本次发布的代码及镜像自动打上版本号并书写 ChangeLog，同时发布到生产环境。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此就完成了上文中 Checklist 所需的所有工作。虽然描述起来看似冗长，但不难发现实际作为开发人员，并没有任何复杂的操作，流程化的部分全部由 CI 完成，开发人员只需要关注自己的核心任务：按照工作流规范，写好代码，写好 Commit，提交代码即可。&lt;/p&gt;
&lt;p&gt;接下来将介绍这个以 CI 为核心的工作流，是如何一步步搭建的。&lt;/p&gt;
&lt;h1 id=&#34;step-by-step-构建-ci-工作流&#34;&gt;Step by Step 构建 CI 工作流&lt;/h1&gt;
&lt;h2 id=&#34;step0-基于-docker-部署-jenkins&#34;&gt;Step.0: 基于 docker 部署 Jenkins&lt;/h2&gt;
&lt;p&gt;运行下面的命令直接启动Jenkins&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run \
  -u root \
  --name jenkins \
  -d \
  --restart always \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  jenkinsci/blueocean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体安装说明可以见我之前的文章&lt;a href=&#34;https://fs.tn/post/WRXr2XyC0/&#34;&gt;Jenkins安装和简单使用&lt;/a&gt;，里面有详细的介绍说明&lt;/p&gt;
&lt;h2 id=&#34;step1-单人工作流自动化单元测试与-docker-镜像构建&#34;&gt;Step.1: 单人工作流，自动化单元测试与 Docker 镜像构建&lt;/h2&gt;
&lt;p&gt;为了方便说明，这里假设项目语言为 Java。&lt;/p&gt;
&lt;p&gt;我们希望将代码打包成 Docker 镜像，根目录下增加了 Dockerfile 文件，这里直接使用 Java的官方镜像，构建过程只有 1 行COPY /target/*.jar /app.jar， 这样镜像运行后可以通过 http 请求看到index.html的内容。&lt;br&gt;
至此我们可以将工作流改进为：&lt;br&gt;
* 当 master 分支接收到 push 后，运行单元测试和构建操作&lt;br&gt;
* gitlab发布一次webhook通知， 构建 Docker 镜像，并推送到Harbor镜像仓库&lt;/p&gt;
&lt;p&gt;对应的 Jenkins 配置文件如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipeline {
    environment {
        CI = &#39;true&#39;
        CON_NAME = &amp;quot;xxxxx&amp;quot;
        HAR_NAME = &amp;quot;test&amp;quot;
        HAR_PASS = &amp;quot;Test12345&amp;quot;
        SONARURL = &amp;quot;http://sonar.com.cn&amp;quot;
        SONARURL_token = &amp;quot;fa0b0f7a5f12fbf7b120e1726b3e4db6ea040e8c&amp;quot;
    }
    agent any
    tools {
        maven &amp;quot;maven3.5.4&amp;quot;
    }
    stages {
        stage(&#39;构建&#39;) {
            steps {
                echo &#39;开始构建&#39;
                sh &#39;mvn -DskipTests clean package&#39;
                echo &#39;构建成功&#39;
            }
        }
				stage(&#39;单元测试&#39;) {
            steps {
                echo &#39;开始单元测试&#39;
                sh &#39;mvn test&#39;
                echo &#39;单元测试成功&#39;
            }
        }
        stage(&#39;代码扫描&#39;) {
            steps {
                echo &#39;开始代码扫描&#39;
                sh &#39;mvn sonar:sonar -Dsonar.host.url=${SONARURL} -Dsonar.login=${SONARURL_token}&#39;
                echo &#39;代码扫描结束&#39;
            }
        }
        stage(&#39;镜像构建&#39;) {
            steps {
                echo &#39;构建镜像并上传到harbor&#39;
                script {
                    //登陆使用的凭据需要提前在Jenkins中添加好
                    def customImage = docker.build(&amp;quot;harbor.asoco.com.cn/${HAR_NAME}/${CON_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    withDockerRegistry(credentialsId: &#39;har-test&#39;, url: &#39;http://harbor.asoco.com.cn&#39;)  {
                    customImage.push(&amp;quot;${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    customImage.push(&amp;quot;latest&amp;quot;)
                    }
                }
                echo &#39;删除本地镜像&#39;
                sh &amp;quot;docker image rm harbor.asoco.com.cn/${HAR_NAME}/${CON_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;
            }
        }
    }
    post {
        failure {
            echo &#39;测试失败&#39;
        }
        success {
            echo &#39;测试成功&#39;
        }
    }
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;step2-gitflow-多分支团队工作流&#34;&gt;Step.2: GitFlow 多分支团队工作流&lt;/h2&gt;
&lt;p&gt;上面的工作流已经基本可以应付单人的开发了，而在团队开发时，这个工作流还需要一些扩展，只需要在上文基础上根据分支做一点调整即可。&lt;br&gt;
对应的 Jenkins 配置文件如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipeline {
    environment {
        CI = &#39;true&#39;
        CON_NAME = &amp;quot;xxxxx&amp;quot;
        HAR_NAME = &amp;quot;test&amp;quot;
        HAR_PASS = &amp;quot;Test12345&amp;quot;
        SONARURL = &amp;quot;http://sonar.com.cn&amp;quot;
        SONARURL_token = &amp;quot;fa0b0f7a5f12fbf7b120e1726b3e4&amp;quot;
        CON_PROT = &amp;quot;8080&amp;quot;
        TEST_ENV = &amp;quot;xxxxx&amp;quot;
        webhook = &amp;quot;https://oapi.dingtalk.com/robot/send?access_token=bfc4d57a02b5a6ea8axxxxxxxxx&amp;quot;
        callphone = &amp;quot;186xxxxxxxx&amp;quot;
    }
    agent any
    tools {
        maven &amp;quot;maven3.5.4&amp;quot;
    }
    stages {
        stage(&#39;构建&#39;) {
            steps {
                echo &#39;开始构建&#39;
                sh &#39;mvn -DskipTests clean package&#39;
                echo &#39;构建成功&#39;
            }
        }
				stage(&#39;单元测试&#39;) {
            steps {
                echo &#39;开始单元测试&#39;
                sh &#39;mvn test&#39;
                echo &#39;单元测试成功&#39;
            }
        }
        stage(&#39;代码扫描&#39;) {
            steps {
                echo &#39;开始代码扫描&#39;
                sh &#39;mvn sonar:sonar -Dsonar.host.url=${SONARURL} -Dsonar.login=${SONARURL_token}&#39;
                echo &#39;代码扫描结束&#39;
            }
        }
        stage(&#39;镜像构建&#39;) {
            steps {
                echo &#39;构建镜像并上传到harbor&#39;
                script {
                    //登陆使用的凭据需要提前在Jenkins中添加好
                    def customImage = docker.build(&amp;quot;harbor.com.cn/${HAR_NAME}/${CON_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    withDockerRegistry(credentialsId: &#39;har-test&#39;, url: &#39;http://harbor.com.cn&#39;)  {
                    customImage.push(&amp;quot;${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    customImage.push(&amp;quot;latest&amp;quot;)
                    }
                }
                echo &#39;删除本地镜像&#39;
                sh &amp;quot;docker image rm harbor.com.cn/${HAR_NAME}/${CON_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;
            }
        }
        stage(&#39;测试环境部署&#39;) {
            agent { label &amp;quot;${TEST_ENV}&amp;quot; }
            when {
                beforeAgent true
                branch &#39;test&#39;
            }
            steps {
                echo &#39;开始环境部署&#39;
                sh &amp;quot;docker login -u ${HAR_NAME} -p ${HAR_PASS} harbor.com.cn&amp;quot;
                sh &amp;quot;docker pull harbor.com.cn/${HAR_NAME}/${CON_NAME}:latest&amp;quot;
                sh &#39;&#39;&#39;if [ $(docker ps -aq --filter name=^/${CON_NAME}$) ]; then docker stop ${CON_NAME} &amp;amp;&amp;amp; docker rm ${CON_NAME};fi&#39;&#39;&#39;
                //自动部署最新版本
                sh &#39;&#39;&#39;docker run -d --name ${CON_NAME} -p ${CON_PROT}:${CON_PROT} harbor.com.cn/${HAR_NAME}/${CON_NAME}:latest --spring.profiles.active=test &#39;&#39;&#39;
                echo &#39;部署结束&#39;
            }
        }
        stage(&#39;接口测试&#39;) {
            steps {
                echo &#39;开始接口自动测试&#39;
                sh &#39;&#39;&#39;
                curl &#39;yapi.com&#39;
                &#39;&#39;&#39;
                echo &#39;测试结束&#39;
            }
        }
    }
    post {
        failure {
            sh &amp;quot;./ding.sh ${webhook} ${callphone} ${CON_NAME} ${BUILD_ID} ${BRANCH_NAME} 测试 失败&amp;quot;
        }
        success {
            sh &amp;quot;./ding.sh ${webhook} ${callphone} ${CON_NAME} ${BUILD_ID} ${BRANCH_NAME} 测试 成功&amp;quot;
        }
    }
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;* 团队成员从 dev 分支 checkout 自己的分支 feature/readme
* 向feature/readme提交代码并 push， CI 运行单元测试，构建镜像ci-demo:readme
* 功能开发完成后，团队成员向 test分支 发起 pull request ， CI 运行单元测试
* 团队其他成员 merge pull request， CI 运行单元测试，构建镜像ci-demo:test并部署到测试环境，测试人员开始测试
* 测试完成后，运维人员从 test向 master 发起 pull request，CI 运行单元测试，并构建镜像ci-demo:latest
* 运维人员 merge pull request， 并 release 新版本 pre-0.0.2， CI 构建镜像ci-demo:pre-0.0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;step3-语义化发布&#34;&gt;Step.3: 语义化发布&lt;/h2&gt;
&lt;p&gt;上面基本完成了一个支持团队协作的半自动 CI 工作流，如果不是特别苛刻的话，完全可以用上面的工作流开始干活了。&lt;/p&gt;
&lt;p&gt;不过基于这个工作流工作一段时间，会发现仍然存在痛点，那就是每次发布都要想一个版本号，写 ChangeLog，并且人工去 release。&lt;/p&gt;
&lt;p&gt;标记版本号涉及到上线后的回滚，追溯等一系列问题,应该是一项严肃的工作，其实如何标记早已有比较好的方案，即语义化版本。在这个方案中，版本号一共有 3 位，形如 1.0.0，分别代表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然有了这个指导意见，但并没有很方便的解决实际问题，每次发布要搞清楚代码的修改到底是不是向下兼容的，有哪些新的功能等，仍然要花费很多时间。&lt;/p&gt;
&lt;p&gt;而&lt;a href=&#34;https://semantic-release.gitbook.io/semantic-release/&#34;&gt;语义化发布 (Semantic Release)&lt;/a&gt; 就能很好的解决这些问题。&lt;/p&gt;
&lt;p&gt;语义化发布的原理很简单，就是让每一次 Commit 所附带的 Message 格式遵守一定规范，保证每次提交格式一致且都是可以被解析的，那么进行 Release 时，只要统计一下距离上次 Release 所有的提交，就分析出本次提交做了何种程度的改动，并可以自动生成版本号、自动生成 ChangeLog 等。&lt;/p&gt;
&lt;p&gt;语义化发布中，Commit 所遵守的规范称为&lt;a href=&#34;https://www.conventionalcommits.org/zh/v1.0.0-beta.3/&#34;&gt;约定式提交 (Conventional Commits)&lt;/a&gt;。比如 node.js、 Angular、Electron 等知名项目都在使用这套规范。&lt;br&gt;
语义化发布首先将 Commit 进行分类，常用的分类 (Type) 有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* feat: 新功能
* fix: BUG 修复
* docs: 文档变更
* style: 文字格式修改
* refactor: 代码重构
* perf: 性能改进
* test: 测试代码
* chore: 工具自动生成
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个 Commit 可以对应一个作用域(Scope)，在一个项目中作用域一般可以指不同的模块。&lt;br&gt;
当 Commit 内容较多时，可以追加正文和脚注，如果正文起始为BREAKING CHANGE，代表这是一个破坏性变更。&lt;br&gt;
以下都是符合规范的 Commit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;feat: 增加重置密码功能
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;fix(邮件模块): 修复邮件发送延迟BUG
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;feat(API): API重构
BREAKING CHANGE: API v3上线，API v1停止支持
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些规范的 Commit，版本号如何变化就很容易确定了，目前语义化发布&lt;a href=&#34;https://github.com/semantic-release/commit-analyzer/blob/master/lib/default-release-rules.js&#34;&gt;默认的规则&lt;/a&gt;如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Commit&lt;/th&gt;
&lt;th&gt;版本号变更&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BREAKING CHANGE&lt;/td&gt;
&lt;td&gt;主版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;feat&lt;/td&gt;
&lt;td&gt;次版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fix / perf&lt;/td&gt;
&lt;td&gt;修订号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有了这套规范，我们就可以清楚的知道，版本号是如何递增的，以及可以及时的追溯相关版本的问题。&lt;/p&gt;
&lt;p&gt;具体如何将语义化发布加入 CI 流程中呢， semantic-release/exec 是 js 实现的，如果是 js 的项目，可以直接在package.json中增加配置项，而对于任意语言的项目，推荐在根目录下增加 配置文件release.config.js。这个配置目的是为了禁用默认开启的 npm 发布机制，可以直接套用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;plugins&amp;quot;: [
    &amp;quot;@semantic-release/commit-analyzer&amp;quot;,
    &amp;quot;@semantic-release/release-notes-generator&amp;quot;,
    [&amp;quot;@semantic-release/exec&amp;quot;, {
      &amp;quot;verifyConditionsCmd&amp;quot;: &amp;quot;./verify.sh&amp;quot;,
      &amp;quot;publishCmd&amp;quot;: &amp;quot;./publish.sh ${nextRelease.version} ${options.branch} ${commits.length} ${Date.now()}&amp;quot;
    }],
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这个例子：&lt;/p&gt;
&lt;p&gt;verifyConditionsCmd命令./verify.sh将在验证条件步骤中执行&lt;br&gt;
publishCmd命令./publish.sh 1.0.0 master 3 870668040000（为的版本发布1.0.0从分支master与3在提交时August 4th, 1997 at 2:14 AM）将在执行发布步骤&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Options&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;verifyConditionsCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在验证条件步骤期间执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#verifyconditionscmd&#34;&gt;verifyConditionsCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;analyzeCommitsCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在分析提交步骤期间执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#analyzecommitscmd&#34;&gt;analyzeCommitsCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;verifyReleaseCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在验证释放步骤期间执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#verifyreleasecmd&#34;&gt;verifyReleaseCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;generateNotesCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在生成注释步骤期间执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#generatenotescmd&#34;&gt;generateNotesCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;prepareCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在准备步骤中执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#preparecmd&#34;&gt;prepareCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;publishCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在发布步骤中执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#publishcmd&#34;&gt;publishCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;successCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在成功步骤中执行的shell命令。见 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#successcmd&#34;&gt;successCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;failCmd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;要在失败步骤期间执行的shell命令。请参阅 &lt;a href=&#34;https://github.com/semantic-release/exec/blob/master/README.md#failcmd&#34;&gt;failCmd&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于运行命令的shell。请参阅 &lt;a href=&#34;https://github.com/sindresorhus/execa#shell&#34;&gt;execa#shell&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;execCwd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行shell命令时用作当前工作目录的路径。此路径与运行语义释放的路径相关。例如，如果语义释放运行/my-project并execCwd设置为，buildScripts则将执行shell命令/my-project/buildScripts&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;来再次模拟一下流程，feature 分支部分与上文相同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 从 test 向 master 发起 pull request，CI 运行单元测试，并构建镜像ci-demo:latest
* merge pull request，CI 会执行单元测试并运行 semantic-release ， 运行成功的话能看到 gitlab 新增 tag v1.0.0
* gitlab tag 再次触发CI 构建生产环境用 Docker 镜像ci-demo:1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终我们能得到这样一个赏心悦目的 tag&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/04/13/5cb1826e6f399.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;后话&#34;&gt;后话&lt;/h1&gt;
&lt;p&gt;总结一下，本文展示了从 Hello World 到 单人单分支手动发布 到 团队多分支 GitFlow 工作流 到 团队多分支 semantic-release 语义化发布 ，如何从零开始一步一步搭建 CI 将团队开发、测试、发布的流程全部自动化的过程，最终能让开发人员只需要认真提交代码就可以完成日常的所有 DevOps 工作。&lt;/p&gt;
&lt;p&gt;最终 Step 的完成品可以适配之前的所有 Step，如果不太在意实现细节的话，可以在此基础上稍作修改，直接使用。&lt;/p&gt;
&lt;p&gt;然而写好每一个 Commit 这个看似简单的要求，其实对于大多数团队来说并不容易做到，在实施过程中，经常会遇到团队成员不理解为什么要重视 Commit 规范，每个 Commit 都要深思熟虑是否过于吹毛求疵等等疑问。&lt;/p&gt;
&lt;p&gt;以 Commit 作为 CI 的核心，个人认为主要会带来以下几方面的影响：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 一个好的 Commit，代表着开发人员对当前改动之于整个系统的影响，有非常清楚的认识，代码的修改到底算 feat 还是 fix ，什么时候用 BREAKING CHANGE 等都是要仔细斟酌的，每个 Commit 都会在 ChangeLog 里“留底”，从而约束团队不随意提交未经思考的代码，提高代码质量
2. 一个好的 Commit 也代表开发人员有能力对所实现功能进行精细的划分，一个分支做的事情不宜过多，一个提交也应该专注于只解决一个问题，每次提交(至少是每次 push )都应该保持系统可构建、可运行、可测试，如果能坚持做到这些，对于合并代码时的冲突解决，以及集成测试都有很大帮助。
3. 由于每次发布能清楚的看到所有关联的 Commit 以及 Commit 的重要程度，那么线上事故的回滚也会非常轻松，回滚到哪个版本，回滚后哪些功能会受到影响，只要看 CI 自动生成的 Release 记录就一目了然。如果没有这些，回滚误伤到预期外的功能从而引发连锁反应的惨痛教训，可能很多运维都有过类似经历吧。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此 CI 自动化其实是锦上添花而非雪中送炭，如果团队原本就无视规范，Commit 全是空白或者没有任何意义的单词，分支管理混乱，发布困难，奢望引入一套自动化 CI 来能解决所有这些问题，无疑是不现实的。而只有原本就重视代码质量，有一定规范意识，再通过自动化 CI 来监督约束，团队在 CI 的帮助下代码质量提高，从而有机会进一步改进 CI 的效率，才能形成良性循环。&lt;/p&gt;
&lt;p&gt;**** 愿天下不再有难发布的版本。&lt;/p&gt;
">Docker 容器环境下的持续集成实践：构建基于 Jenkins + GitFlow + docker 的CI 工作流</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/FflmRqk90/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E8%80%83&#34;&gt;思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9E%84%E5%BB%BAdocker%E7%8E%AF%E5%A2%83&#34;&gt;构建docker环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95&#34;&gt;使用方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F&#34;&gt;直接使用镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jenkins%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F&#34;&gt;Jenkins中使用镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;思考&#34;&gt;思考&lt;/h1&gt;
&lt;p&gt;采用docker编译我们可以在本地不配置任何环境，只要安装docker，并下载docker镜像就好了。我在其他机器想编译，那我只需要把镜像pull下来，运行就好了。如果没有我们想要的镜像，我们可以自己配置，然后上传到docker hub，留着以后什么时候需要就下载。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;构建docker环境&#34;&gt;构建docker环境&lt;/h1&gt;
&lt;p&gt;这里使用dockerfile来构建android的编译环境。如果不想自己构建，也可以直接用我构建好的镜像：registry.cn-hangzhou.aliyuncs.com/lm93129/android_env:v1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:18.10

MAINTAINER Yang zixi

ENV ANDROID_HOME=&amp;quot;/opt/android-sdk&amp;quot; \
    JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/

# 获取最新版本的sdktools地址：https://developer.android.com/studio/index.html
ENV ANDROID_SDK_TOOLS_VERSION=&amp;quot;4333796&amp;quot;

# 设置本地语言
ENV LANG=&amp;quot;en_US.UTF-8&amp;quot; \
    LANGUAGE=&amp;quot;en_US.UTF-8&amp;quot; \
    LC_ALL=&amp;quot;en_US.UTF-8&amp;quot;

RUN apt-get clean &amp;amp;&amp;amp; apt-get update -qq &amp;amp;&amp;amp; apt-get install -qq -y apt-utils locales &amp;amp;&amp;amp; locale-gen $LANG

ENV DEBIAN_FRONTEND=&amp;quot;noninteractive&amp;quot; \
    TERM=dumb \
    DEBIAN_FRONTEND=noninteractive

# 设置android环境变量
ENV ANDROID_SDK_HOME=&amp;quot;$ANDROID_HOME&amp;quot;

ENV PATH=&amp;quot;$PATH:$ANDROID_SDK_HOME/emulator:$ANDROID_SDK_HOME/tools/bin:$ANDROID_SDK_HOME/tools:$ANDROID_SDK_HOME/platform-tools:$ANDROID_NDK:$FLUTTER_HOME/bin:$FLUTTER_HOME/bin/cache/dart-sdk/bin&amp;quot;

WORKDIR /tmp

# 安装一些依赖包，这里由于我个人需要，所以多安装了一些，可以根据自己的实际情况，少安装一些包
RUN apt-get update -qq &amp;gt; /dev/null &amp;amp;&amp;amp; \
    apt-get install -qq locales &amp;gt; /dev/null &amp;amp;&amp;amp; \
    locale-gen &amp;quot;$LANG&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    apt-get install -qq --no-install-recommends \
        build-essential \
        autoconf \
        curl \
        git \
        lib32stdc++6 \
        lib32z1 \
        lib32z1-dev \
        libc6-dev \
        libgmp-dev \
        libmpc-dev \
        libmpfr-dev \
        libxslt-dev \
        libxml2-dev \
        m4 \
        ncurses-dev \
        ocaml \
        openjdk-8-jdk \
        openssh-client \
        pkg-config \
        software-properties-common \
        unzip \
        wget \
        zip \
        zlib1g-dev &amp;gt; /dev/null

# 安装SDK
RUN echo &amp;quot;Installing sdk tools ${ANDROID_SDK_TOOLS_VERSION}&amp;quot; &amp;amp;&amp;amp; \
    wget --quiet --output-document=sdk-tools.zip \
        &amp;quot;https://dl.google.com/android/repository/sdk-tools-linux-${ANDROID_SDK_TOOLS_VERSION}.zip&amp;quot; &amp;amp;&amp;amp; \
    mkdir --parents &amp;quot;$ANDROID_HOME&amp;quot; &amp;amp;&amp;amp; \
    unzip -q sdk-tools.zip -d &amp;quot;$ANDROID_HOME&amp;quot; &amp;amp;&amp;amp; \
    rm --force sdk-tools.zip &amp;amp;&amp;amp; \
# 安装sdk中的组件，可以根据需要自行修改
    mkdir --parents &amp;quot;$ANDROID_HOME/.android/&amp;quot; &amp;amp;&amp;amp; \
    echo &#39;### User Sources for Android SDK Manager&#39; &amp;gt; \
        &amp;quot;$ANDROID_HOME/.android/repositories.cfg&amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager --licenses &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing platforms&amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;platforms;android-28&amp;quot; \
        &amp;quot;platforms;android-27&amp;quot; \
        &amp;quot;platforms;android-26&amp;quot; \
        &amp;quot;platforms;android-25&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing platform tools &amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;platform-tools&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing build tools &amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;build-tools;28.0.3&amp;quot; &amp;quot;build-tools;28.0.2&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing extras &amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;extras;android;m2repository&amp;quot; \
        &amp;quot;extras;google;m2repository&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing play services &amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;extras;google;google_play_services&amp;quot; \
        &amp;quot;extras;m2repository;com;android;support;constraint;constraint-layout;1.0.2&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    echo &amp;quot;Installing Google APIs&amp;quot; &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager \
        &amp;quot;add-ons;addon-google_apis-google-24&amp;quot; \
        &amp;quot;add-ons;addon-google_apis-google-23&amp;quot; &amp;gt; /dev/null &amp;amp;&amp;amp; \
    yes | &amp;quot;$ANDROID_HOME&amp;quot;/tools/bin/sdkmanager --licenses

# 设置Jenkins的环境
RUN mkdir -p /var/lib/jenkins/workspace
RUN mkdir -p /home/jenkins
RUN chmod 777 /home/jenkins
RUN chmod 777 /var/lib/jenkins/workspace
RUN chmod 777 $ANDROID_HOME/.android
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存上面的代码为Dockerfile，然后运行&lt;code&gt;docker build -t android_builder:v1 .&lt;/code&gt; 就可以构建镜像。构建过程，需要下载谷歌的东西，所以国内网络可能会有问题，请注意网络，或者自行再构建过程中加入代理，我这里使用国外的服务器构建的，所以没有该问题。&lt;br&gt;
这个镜像可以根据需要自己进行扩展，比如我这里只有android25-28的。如果你需要其他的，也可以自己再加。&lt;/p&gt;
&lt;h1 id=&#34;使用方法&#34;&gt;使用方法&lt;/h1&gt;
&lt;h2 id=&#34;直接使用镜像&#34;&gt;直接使用镜像&lt;/h2&gt;
&lt;p&gt;我们可以将android项目目录挂载到容器中，然后运行命令即可。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it --rm -v /home/android:/home/builder/workdir -u 0:0 android_builder:v1 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后进入/home/builder/workdir中运行构建命令即可，上面使用了--rm命令，所以再容器关闭后会自动销毁。&lt;/p&gt;
&lt;h2 id=&#34;jenkins中使用镜像&#34;&gt;Jenkins中使用镜像&lt;/h2&gt;
&lt;p&gt;直接贴上pipeline的代码，其中镜像可以挂载/root/.gradle目录，可以实现不需要每次都下载依赖。然后关于蒲公英的上传，这里只是做了一个示例。这个脚本里面还可以再扩展下，比如构建完成之后钉钉通知下载app之类的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipeline {
    environment {
        CI = &#39;true&#39;
    }
    agent {
        docker {
            image &#39;registry.cn-hangzhou.aliyuncs.com/lm93129/android_env:v1&#39;
            args  &#39;-v /docker/ci-cache/.gradle:/root/.gradle&#39;
        }
    }
    parameters {
        listGitBranches branchFilter: &#39;*&#39;, credentialsId: &#39;gitlab&#39;, defaultValue: &#39;master&#39;, name: &#39;prj_tag&#39;, quickFilterEnabled: false, remoteURL: &#39;http://gitlab.com.cn/asoco/xxxx.git&#39;, selectedValue: &#39;NONE&#39;, sortMode: &#39;DESCENDING_SMART&#39;, tagFilter: &#39;*&#39;, type: &#39;PT_BRANCH&#39;
    }
    stages {
        stage(&#39;构建&#39;) {
            steps {
                echo &#39;开始构建&#39;
                git credentialsId: &#39;gitlab&#39;, url: &#39;http://gitlab.com.cn/asoco/xxxx.git&#39;
                sh &#39;git checkout ${prj_tag}&#39;
                sh &#39;/bin/bash gradlew assembleRelease&#39;
                echo &#39;构建成功&#39;
            }
        }
        stage(&#39;代码扫描&#39;) {
            steps {
                echo &#39;开始代码扫描&#39;
                sh &#39;./gradlew sonarqube&#39;
                echo &#39;代码扫描结束&#39;
            }
        }
        stage(&#39;apk上传&#39;) {
            steps {
                echo &#39;上传代码到蒲公英&#39;
                sh &amp;quot;curl -F &amp;quot;file=@/tmp/*.apk&amp;quot; -F &amp;quot;uKey=&amp;quot; -F &amp;quot;_api_key=&amp;quot; https://qiniu-storage.pgyer.com/apiv1/app/upload &amp;quot;
            }
        }
    }
    post {
        failure {
            echo &#39;失败&#39;
        }
        success {
            archiveArtifacts artifacts: &#39;app/build/outputs/apk/release/*.apk&#39;, fingerprint: true
        }
    }
}   
&lt;/code&gt;&lt;/pre&gt;
">使用docker编译Android源码（支持Jenkins）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/4vvRZ8Q6x/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E4%BB%8B&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%9A%E8%BF%87-blue-ocean-%E5%88%9B%E5%BB%BA&#34;&gt;通过 Blue Ocean 创建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E5%86%99jenkinsfilepipeline%E8%84%9A%E6%9C%AC&#34;&gt;编写Jenkinsfile（pipeline脚本）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA&#34;&gt;maven项目构建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#maven%E7%9A%84pipeline&#34;&gt;maven的pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dockerfile%E6%96%87%E4%BB%B6&#34;&gt;dockerfile文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dingsh%E6%96%87%E4%BB%B6&#34;&gt;ding.sh文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;Jenkins流水线是一套插件，它支持实现和集成持续交付流水线到 Jenkins。流水线提供了一组可扩展的工具，用于通过流水线 DSL将简单到复杂的交付流水线建模为 &amp;quot;代码&amp;quot;。本文只是简单的介绍了下Jenkinsfile文件的编写，还有许多不足和可以优化改进的地方。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;通过-blue-ocean-创建&#34;&gt;通过 Blue Ocean 创建&lt;/h1&gt;
&lt;p&gt;在上一篇Jenkins的简单使用文章中，已经介绍了使用blue ocean图形化创建pipeline。但是这种方式，创建出来的pipeline往往不符合我们的要求，直接写脚本的形式，可能更容易理解一点。所以本文主要介绍pipeline脚本的编写，再编写Jenkinsfile之前，最好先看看官方的教程，了解Jenkins的pipeline语法。&lt;/p&gt;
&lt;h1 id=&#34;编写jenkinsfilepipeline脚本&#34;&gt;编写Jenkinsfile（pipeline脚本）&lt;/h1&gt;
&lt;h2 id=&#34;maven项目构建&#34;&gt;maven项目构建&lt;/h2&gt;
&lt;p&gt;先附上完整的pipeline脚本，然后再对其中的命令做对应的解释。而官方有的基础命令，则本文不再多做解释了，建议直接访问官网&lt;a href=&#34;https://jenkins.io/zh/doc/book/pipeline/syntax/&#34;&gt;流水线语法参考&lt;/a&gt; 学习其中的命令&lt;/p&gt;
&lt;h3 id=&#34;maven的pipeline&#34;&gt;maven的pipeline&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pipeline {
    //设置环境变量
    environment {
        CI = &#39;true&#39;
        HAR_NAME = &amp;quot;test&amp;quot;
        HAR_PASS = &amp;quot;Test12345&amp;quot;
        SONARURL = &amp;quot;http://sonar.com&amp;quot;
        SONARURL_token = &amp;quot;bb99xxxxxxx0bad5cf4&amp;quot;
        CON_PROT = &amp;quot;8002&amp;quot;
        TEST_ENV = &amp;quot;XXXX-test&amp;quot;
        DEV_ENV = &amp;quot;XXXX-dev&amp;quot;
    }
    agent any
		//设置构建的参数
		parameters {
		//设置环境部署参数
        choice choices: [&#39;test&#39;, &#39;dev&#39;, &#39;not&#39;], description: &#39;选择需要部署的环境,不需要部署则选择not&#39;, name: &#39;DEPLOY_TO&#39;
		//读取git的tag数据，该功能需要安装插件
        listGitBranches branchFilter: &#39;origin/(.*)&#39;, credentialsId: &#39;gitlab&#39;, defaultValue: &#39;master&#39;, name: &#39;tag&#39;, quickFilterEnabled: false, remoteURL: &#39;http://gitlab.com.cn/xxx/xxx.git&#39;, selectedValue: &#39;NONE&#39;, sortMode: &#39;DESCENDING_SMART&#39;, tagFilter: &#39;*&#39;, type: &#39;PT_TAG&#39;
		//设置钉钉的webhook
        string defaultValue: &#39;https://oapi.dingtalk.com/robot/send?access_token=e706xxxf835279xxxx9453xxxxxx1561&#39;, description: &#39;钉钉webhook通知地址&#39;, name: &#39;webhook&#39;, trim: false
		//设置字符参数callphone，默认值是18677371111
        string defaultValue: &#39;18677371111&#39;, description: &#39;通知人&#39;, name: &#39;callphone&#39;, trim: false
    }
	//设置构建需要用到的工具，该工具需要先在Jenkins中配置好
    tools {
        maven &amp;quot;maven3.5.4&amp;quot;
    }
    stages {
        stage(&#39;构建&#39;) {
            steps {
                echo &#39;开始构建&#39;
				//拉去git代码，需要先配置好相应凭据
                git credentialsId: &#39;gitlab&#39;, url: &#39;http://gitlab.com.cn/xxx/xxx.git&#39;
				//切换分支
                sh &#39;git checkout ${tag}&#39;
				//构建
                sh &#39;mvn -DskipTests clean package&#39;
                echo &#39;构建成功&#39;
            }
        }
        stage(&#39;代码扫描&#39;) {
            steps {
                echo &#39;开始代码扫描&#39;
                sh &#39;mvn sonar:sonar -Dsonar.host.url=${SONARURL} -Dsonar.login=${SONARURL_token}&#39;
                echo &#39;代码扫描结束&#39;
            }
        }
        stage(&#39;镜像构建&#39;) {
            steps {
                echo &#39;构建镜像并上传到harbor&#39;
                script {
                    //登陆使用的凭据需要提前在Jenkins中添加好                
                    def customImage = docker.build(&amp;quot;harbor.com.cn/${HAR_NAME}/${JOB_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    withDockerRegistry(credentialsId: &#39;har-test&#39;, url: &#39;http://harbor.com.cn&#39;)  {
                    customImage.push(&amp;quot;${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;) 
                    customImage.push(&amp;quot;latest&amp;quot;)
                    }
                }
				//这里为了节约空间，所以在上传到harbor之后，就删除本地的镜像
                echo &#39;删除本地镜像&#39;
                sh &amp;quot;docker image rm harbor.com.cn/${HAR_NAME}/${JOB_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;
            }
        }
        stage(&#39;测试环境部署&#39;) {
		    //定义部署的节点机
            agent { label &amp;quot;${TEST_ENV}&amp;quot; }
			//定义该步骤不拉取代码
            options { skipDefaultCheckout() }
			//当构建参数为test的时候，才执行该步骤
            when {
                beforeAgent true
                environment ignoreCase: true, name: &#39;DEPLOY_TO&#39;, value: &#39;test&#39;
            }
            steps {
                echo &#39;开始环境部署&#39;
				//登陆harbor
                sh &amp;quot;docker login -u ${HAR_NAME} -p ${HAR_PASS} harbor.com.cn&amp;quot;
				//拉去镜像
                sh &amp;quot;docker pull harbor.com.cn/${HAR_NAME}/${JOB_NAME}:latest&amp;quot;
				//删除和停止原本的容器
                sh &#39;&#39;&#39;if [ $(docker ps -aq --filter name=^/${JOB_NAME}$) ]; then docker stop ${JOB_NAME} &amp;amp;&amp;amp; docker rm ${JOB_NAME};fi&#39;&#39;&#39;
                //自动部署最新版本
                sh &#39;&#39;&#39;docker run -d --name ${JOB_NAME} -p ${CON_PROT}:${CON_PROT} harbor.com.cn/${HAR_NAME}/${JOB_NAME}:latest --spring.profiles.active=test &#39;&#39;&#39;
                echo &#39;部署结束&#39;
            }
        }
        stage(&#39;接口测试&#39;) {
            when {
                branch &#39;master&#39;
            }
            steps {
                echo &#39;开始接口测试&#39;
                sh &#39;&#39;&#39;
                curl &#39;yapi.com&#39;
                &#39;&#39;&#39;
                echo &#39;接口测试结束&#39;
            }
        }
    }
    post {
        failure {
		//钉钉通知，使用的是一个简单的shell脚本，传入相关参数即可
            sh &amp;quot;ding.sh ${webhook} ${callphone} ${JOB_NAME} ${BUILD_ID} ${BUILD_TAG} ${esdb_tag} 失败&amp;quot;
        }
        success {
		//钉钉通知
            sh &amp;quot;ding.sh ${webhook} ${callphone} ${JOB_NAME} ${BUILD_ID} ${BUILD_TAG} ${esdb_tag} 失败&amp;quot;
        }
    }
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dockerfile文件&#34;&gt;dockerfile文件&lt;/h3&gt;
&lt;p&gt;上面的Jenkinsfile中，是构建为docker镜像的形式，所以需要一个dockerfile文件，通常像下面这个就可以了。设置了时区为中国时区。基础镜像也是使用alpine的，体积比较小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM java:8-jdk-alpine
VOLUME /tmp
ADD /target/*.jar /app.jar
RUN apk --no-cache add tzdata  &amp;amp;&amp;amp; \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; \
    echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone 
ENTRYPOINT [&amp;quot;java&amp;quot;,&amp;quot;-Djava.security.egd=file:/dev/./urandom&amp;quot;,&amp;quot;-jar&amp;quot;, &amp;quot;app.jar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dingsh文件&#34;&gt;ding.sh文件&lt;/h3&gt;
&lt;p&gt;构建完成之后，我们需要知道构建结果，就可以使用钉钉群的webhook功能，当然也有邮件、微信，qq等其他方式通知，这个就需要去自己探索了。这里给出上面Jenkinsfile中的ding.sh文件，里面需要修改下Jenkins地址为自己的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh

usage () {
  echo &amp;quot;Usage: ding.sh [webhook] [cell-phone number] [JOB_NAME] [BUILD_ID] [BUILD_TAG] [deploy_env] [STATUS]&amp;quot;;
  echo &amp;quot;       [webhook]: 钉钉聊天机器人webhook。&amp;quot;;
  echo &amp;quot;       [cell-phone number]: 要@的成员手机号。&amp;quot;;
  echo &amp;quot;       [JOB_NAME]: Jenkins的构建项目名&amp;quot;;
  echo &amp;quot;       [BUILD_ID]: Jenkins的构建ID&amp;quot;;
  echo &amp;quot;       [BUILD_TAG]: 构建的分支&amp;quot;;
  echo &amp;quot;       [deploy_env]: 部署的环境&amp;quot;;
  echo &amp;quot;       [STATUS]: 状态&amp;quot;;
  exit 1;
}

WEB_HOOK=$1	

AT=$2

JOB_NAME=$3

BUILD_ID=$4

BUILD_TAG=$5

deploy_env=$6

STATUS=$7

TIME=$(date &amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;)


shift 2

make(){
curl ${WEB_HOOK} -H &amp;quot;Content-type: application/json&amp;quot; -X POST -d &amp;quot;
{
     &amp;quot;msgtype&amp;quot;: &#39;markdown&#39;,
     &amp;quot;markdown&amp;quot;: {
     &amp;quot;title&amp;quot;:&#39;持续集成机器人&#39;,
     &amp;quot;text&amp;quot;:&#39;
# CI/CD机器人：构建${STATUS}\n\n 执行任务:代码扫描+构建+${deploy_env}环境部署\n\n 构建时间:${TIME} \n\n 项目名称:${JOB_NAME}\n\n 构建编号:${BUILD_ID} \n\n 构建版本:${BUILD_TAG}\n\n [点击查看](http://Jenkins.com/blue/organizations/jenkins/${JOB_NAME}/detail/${JOB_NAME}/${BUILD_ID})

@${AT}
&#39;

     },
      &amp;quot;at&amp;quot;: {
          &amp;quot;atMobiles&amp;quot;: [
              &amp;quot;$AT&amp;quot;
          ],
          &amp;quot;isAtAll&amp;quot;: false
      }

}&amp;quot;

}

make $@

&lt;/code&gt;&lt;/pre&gt;
">Jenkinsfile编写简单说明（pipeline scrip）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/WRXr2XyC0/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E4%BB%8B&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA&#34;&gt;环境构建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E5%AE%89%E8%A3%85jenkins&#34;&gt;docker安装Jenkins&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&#34;&gt;环境配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85jenkins&#34;&gt;docker的方式安装Jenkins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86jenkins&#34;&gt;首次登陆Jenkins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6&#34;&gt;安装插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5-%E7%A7%81%E6%9C%89-git-%E4%BB%93%E5%BA%93%E5%B8%90%E5%8F%B7%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E7%89%88&#34;&gt;项目接入-私有 Git 仓库帐号配置（通用版）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AEssh%E5%87%AD%E6%8D%AE&#34;&gt;配置ssh凭据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%A4%9A%E5%88%86%E6%94%AF%E6%B5%81%E6%B0%B4%E7%BA%BF&#34;&gt;添加一个项目（多分支流水线）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B5%81%E6%B0%B4%E7%BA%BF&#34;&gt;创建一个流水线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5%E6%9E%84%E5%BB%BA%E7%A8%8B%E5%BA%8F&#34;&gt;第一步构建程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E6%89%AB%E6%8F%8F%E4%BB%A3%E7%A0%81&#34;&gt;第二步扫描代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5&#34;&gt;构建docker镜像（不需要构建docker镜像的可以省略）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B&#34;&gt;其他构建流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pipeline-%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99&#34;&gt;pipeline 文件编写&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jenkins%E6%8D%A2%E7%9A%AE%E8%82%A4&#34;&gt;Jenkins换皮肤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jenkins%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E6%9C%BA&#34;&gt;Jenkins添加节点机&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;Jenkins是开源CI&amp;amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;环境构建&#34;&gt;环境构建&lt;/h1&gt;
&lt;h2 id=&#34;docker安装jenkins&#34;&gt;docker安装Jenkins&lt;/h2&gt;
&lt;h3 id=&#34;环境配置&#34;&gt;环境配置&lt;/h3&gt;
&lt;p&gt;第一次使用 Jenkins，您需要：&lt;br&gt;
机器要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;256 MB 内存，建议大于 512 MB&lt;/li&gt;
&lt;li&gt;10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要安装以下软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 8 ( JRE 或者 JDK 都可以)&lt;/li&gt;
&lt;li&gt;Docker （导航到网站顶部的Get Docker链接以访问适合您平台的Docker下载）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;docker的安装这里不多做描述，可以自行百度或者google。&lt;/p&gt;
&lt;h3 id=&#34;docker的方式安装jenkins&#34;&gt;docker的方式安装Jenkins&lt;/h3&gt;
&lt;p&gt;运行下面的命令直接启动Jenkins&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run \
  -u root \
  --name jenkins \
  -d \
  --restart always \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  jenkinsci/blueocean
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-u root 是使用root账户，如果不加这个，则默认使用Jenkins账户&lt;/li&gt;
&lt;li&gt;-d 后台运行容器&lt;/li&gt;
&lt;li&gt;--restart always 可以让Jenkins自动重启&lt;/li&gt;
&lt;li&gt;-p 8080:8080映射访问端口&lt;/li&gt;
&lt;li&gt;-p 50000:50000映射节点机通信端口&lt;/li&gt;
&lt;li&gt;-v jenkins-data:/var/jenkins_home 挂载数据卷，如果不使用数据卷的方式，也可以直接映射到本地磁盘。像这样&lt;code&gt;-v $HOME/jenkins:/var/jenkins_home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v /var/run/docker.sock:/var/run/docker.sock&lt;/code&gt;挂载docker到容器，实现docker in docker，这样在容器中的Jenkins就可以使用docker命令&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;首次登陆jenkins&#34;&gt;首次登陆Jenkins&lt;/h3&gt;
&lt;p&gt;第一次访问Jenkins需要一个自动生成的密码来解锁，这个密码可以通过查看容器日志来获取.&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88f3b034470.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用如下命令查看容器日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker logs -f jenkins
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88f3c5e0499.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;安装插件&#34;&gt;安装插件&lt;/h3&gt;
&lt;p&gt;由于Jenkins的插件源默认是在国外的，国内下载会出现超时等无法下载的情况，所以需要加上一个国内源实现加速下载。方法如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进入：系统管理 / 管理插件 / 高级 ，在 Update Site 中填入华为镜像源https://repo.huaweicloud.com/jenkins/update-center.json&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设置完镜像源之后，就可以直接可选插件中，安装想要安装的插件了。常用的会需要安装maven、gradle、git、sonar等插件，需要自行安装。&lt;/p&gt;
&lt;h2 id=&#34;项目接入-私有-git-仓库帐号配置通用版&#34;&gt;项目接入-私有 Git 仓库帐号配置（通用版）&lt;/h2&gt;
&lt;h3 id=&#34;配置ssh凭据&#34;&gt;配置ssh凭据&lt;/h3&gt;
&lt;p&gt;在linux中生成一个ssh-key。使用命令&lt;code&gt;ssh-keygen&lt;/code&gt;，然后一路回车即可生成2个文件，其中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;公钥内容在 ~/.ssh/id_rsa.pub&lt;br&gt;
私有内容在 ~/.ssh/id_rsa&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将公钥导入到gitlab或者GitHub的SSH 密钥中。&lt;br&gt;
然后将私钥导入到Jenkins的凭据中，方法如下：&lt;/p&gt;
&lt;p&gt;在 Jenkins -&amp;gt;Credentials-&amp;gt;System--&amp;gt; Add credentials 新增一个凭据。选择SSH Username with private key&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88f5b61f058.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将私钥的内容完整的复制到里面，并且设置好git的用户名&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88f60d1ebc4.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果不想像上面那样配置ssh-key，也可以直接配置账户密码。&lt;/p&gt;
&lt;h3 id=&#34;添加一个项目多分支流水线&#34;&gt;添加一个项目（多分支流水线）&lt;/h3&gt;
&lt;h4 id=&#34;创建一个流水线&#34;&gt;创建一个流水线&lt;/h4&gt;
&lt;p&gt;在主页，点击Blue Ocean，然后创建一个流水线。选择git。按照步骤输入git地址，注意这里需要使用git协议的地址，而不是http协议的。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/14/5c89b0fa0bb79.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后复制里面给出的Jenkins公钥到git的SSH 密钥中。这里不使用上面配置的凭据，因为这里会自动生成一个给你。&lt;br&gt;
配置好了之后，就可以手动编写流水线了。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/14/5c89b2508f9bf.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
设置代理，代理就是运行程序的节点，可以是docker，可以是k8s，也可以是指定的虚拟机或者物理机。设置成any，则是所有的节点都可以运行。然后设置一些环境变量。&lt;/p&gt;
&lt;h4 id=&#34;第一步构建程序&#34;&gt;第一步构建程序&lt;/h4&gt;
&lt;p&gt;设置好了环境之后，第一步就是编译。&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/14/5c89b307835f3.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新建一个shell脚本，然后输入maven的build命令（其他的程序构建则需要对应的构建命令和构建环境）&lt;/p&gt;
&lt;h4 id=&#34;第二步扫描代码&#34;&gt;第二步扫描代码&lt;/h4&gt;
&lt;p&gt;扫描代码使用的命令可以查看我上一篇文章里面的sonarqube代码扫描，然后新建一个shell脚本步骤，写入命令即可&lt;/p&gt;
&lt;h4 id=&#34;构建docker镜像不需要构建docker镜像的可以省略&#34;&gt;构建docker镜像（不需要构建docker镜像的可以省略）&lt;/h4&gt;
&lt;p&gt;这一步是从使用项目中的dockerfile文件，构建一个docker镜像，并上传到harbor中（关于部署和harbor的使用可以看之前的文章）。先新建一个pipeline scrip，然后输入如下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def customImage = docker.build(&amp;quot;harbor.com.cn/${HAR_NAME}/${JOB_NAME}:${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;)
                    withDockerRegistry(credentialsId: &#39;har-test&#39;, url: &#39;http://harbor.com.cn&#39;)  {
                    customImage.push(&amp;quot;${env.GIT_BRANCH}-${env.BUILD_NUMBER}&amp;quot;) 
                    customImage.push(&amp;quot;latest&amp;quot;)
                    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用docker build 构建一个符合harbor命名规则的镜像，其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;/mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;为&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;环&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;境&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;户&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;名&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{HAR_NAME}为环境变量中harbor的用户名，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.84444em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;为&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;环&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;境&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;户&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;名&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{JOB_NAME}为系统自带的环境变量，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;R&lt;/mi&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;H&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{env.GIT_BRANCH}-&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.00773em;&#34;&gt;R&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.08125em;&#34;&gt;H&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{env.BUILD_NUMBER}为系统自带的环境变量，可以用与生成本次构建的唯一tag&lt;/li&gt;
&lt;li&gt;withDockerRegistry命令为使用harbor的命令，使用harbor的登陆凭据为har-test，需要先在Jenkins的凭据中自己添加好。&lt;/li&gt;
&lt;li&gt;customImage.push命令为推送镜像到harbor，后面跟的是镜像的标签&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;其他构建流程&#34;&gt;其他构建流程&lt;/h3&gt;
&lt;p&gt;更详细的构建流程和pipeline文件编写，可以参考官网的中文教程。&lt;a href=&#34;https://jenkins.io/zh/doc/tutorials/&#34;&gt;Jenkins教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;pipeline-文件编写&#34;&gt;pipeline 文件编写&lt;/h3&gt;
&lt;p&gt;可以根据上面的官网教程，编写一个Jenkinsfile文件在项目中，这样在使用blue ocean创建多分支流水线的时候，会自动读取项目中的Jenkinsfile文件中的pipeline脚本。具体编写就不在这里列举了。&lt;/p&gt;
&lt;h2 id=&#34;jenkins换皮肤&#34;&gt;Jenkins换皮肤&lt;/h2&gt;
&lt;p&gt;打开css生成网址&lt;a href=&#34;http://afonsof.com/jenkins-material-theme/&#34;&gt;jenkins-material-theme&lt;/a&gt; 选择你喜欢的风格，生成css&lt;br&gt;
Jenkins中安装Jenkins Simple Theme Plugin插件，然后再系统设置中找到Theme设置，把css复制进去，保存即可改变Jenkins的原生界面&lt;/p&gt;
&lt;h2 id=&#34;jenkins添加节点机&#34;&gt;Jenkins添加节点机&lt;/h2&gt;
&lt;p&gt;在系统管理中选择节点管理，选择添加一个节点&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/14/5c89c4af34dc9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加完成之后，点击添加后的节点，然后点击relaunch agent，等会就自动连接好了，如果提示找不到Java，则是节点需要安装好Java，或者在添加节点的时候设置好Java_home&lt;/p&gt;
">Jenkins的安装（docker）和简单的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/j8PAuWkv5/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E4%BB%8B&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA&#34;&gt;环境搭建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8&#34;&gt;快速启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%A8%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8&#34;&gt;全配置启动&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E5%90%AF%E5%8A%A8postgres&#34;&gt;docker启动postgres&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E5%90%AF%E5%8A%A8sonarqube&#34;&gt;docker启动sonarqube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-compose%E5%90%AF%E5%8A%A8&#34;&gt;docker-compose启动&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%88%E6%9E%9C&#34;&gt;效果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6&#34;&gt;安装插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8sonar%E6%89%AB%E6%8F%8F%E4%BB%A3%E7%A0%81&#34;&gt;使用sonar扫描代码&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#maven%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE&#34;&gt;maven项目配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gradle%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE&#34;&gt;gradle项目配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nodejs%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE&#34;&gt;nodejs项目配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sonar-projectproperties%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B&#34;&gt;sonar-project.properties文件示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;SonarQube(原名Sonar)是一个开源的代码质量管理系统,可以扫描项目中重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释等.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;支持Java、C/C++、C#、PHP、Flex、Groovy、JavaScript、Python等多种语言.&lt;/p&gt;
&lt;p&gt;代码扫码的好处在于通过配置规则扫描代码设计缺陷和代码优化从而提高代码的质量.&lt;br&gt;
本文介绍使用docker技术搭建SonarQube环境并扫描代码.&lt;/p&gt;
&lt;h1 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h1&gt;
&lt;h2 id=&#34;快速启动&#34;&gt;快速启动&lt;/h2&gt;
&lt;p&gt;这种方式启动sonarqube是没有数据存储的,docker重新加载后数据不会reload数据.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube:lts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器打开:0.0.0.0:9000&lt;br&gt;
帐号密码:admin、admin&lt;/p&gt;
&lt;h2 id=&#34;全配置启动&#34;&gt;全配置启动&lt;/h2&gt;
&lt;h3 id=&#34;docker启动postgres&#34;&gt;docker启动postgres&lt;/h3&gt;
&lt;p&gt;使用postgres作为数据存储,通过如下命令启动:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name postgres -e POSTGRES_PASSWORD=password -e POSTGRES_USER=sonar -p 5432:5432 -d postgres:9.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sonarqube不支持mysql5.5版本,最低支持5.6版本&lt;/p&gt;
&lt;h3 id=&#34;docker启动sonarqube&#34;&gt;docker启动sonarqube&lt;/h3&gt;
&lt;p&gt;需要注意两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要先启动postgres,数据库会自动创建&lt;/li&gt;
&lt;li&gt;本地搭建ip地址不能写localhost,需要写内网ip&lt;br&gt;
启动命令如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --name sonarqube \
    -p 9000:9000 \
    -p 9092:9092 \
    -e sonar.jdbc.username=sonar \
    -e sonar.jdbc.password=password \
    -e sonar.jdbc.url=jdbc:postgresql://db:5432/sonar \
    --link postgres:db \
    sonarqube
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;浏览器打开:0.0.0.0:9000&lt;br&gt;
帐号密码:admin、admin&lt;/p&gt;
&lt;h2 id=&#34;docker-compose启动&#34;&gt;docker-compose启动&lt;/h2&gt;
&lt;p&gt;先从官网下载sonarqube6.7版本，解压后重命名为sonarqube。在目录中新建一个docker-compose.yaml文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &amp;quot;3.3&amp;quot;
services:
  db:
    image: postgres
    container_name: postgres
    ports:
        - &amp;quot;5432:5432&amp;quot; 
    environment:
        - POSTGRES_USER=sonar 
        - POSTGRES_PASSWORD=sonar
    volumes:
        - /var/lib/postgresql/data
    networks:
      main:
        aliases:
          - db

  adminer:
    image: adminer
    restart: always
    ports:
      - 8088:8080
    networks:
      main:
        aliases:
          - adminer

  sonarqube:
    image: sonarqube:6.7-community
    container_name: sonarqube
    ports:
      - &amp;quot;9000:9000&amp;quot;
      - &amp;quot;9092:9092&amp;quot;
    volumes:
        - ~/sonarqube/conf:/opt/sonarqube/conf
        - ~/sonarqube/data:/opt/sonarqube/data
        - ~/sonarqube/extensions:/opt/sonarqube/extensions
        - ~/sonarqube/elasticsearch:/opt/sonarqube/elasticsearch
    environment:
      - SONARQUBE_JDBC_URL=jdbc:postgresql://db:5432/sonar
    privileged: true
    networks:
      main:
        aliases:
          - sonarqube

networks:
  main:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样启动的好处是，可以方便的手动安装插件，也可以保证每次重启sonarqube服务之后，数据仍然保留。建议可以提前手动下载一些常用插件，如汉化，Android lint插件&lt;/p&gt;
&lt;p&gt;如果需要配置域名，可以自己用nginx做个反向代理就OK了。&lt;/p&gt;
&lt;h3 id=&#34;效果&#34;&gt;效果&lt;/h3&gt;
&lt;p&gt;启动成功以后,第一次页登录成功后会设置token,这个token是以后被扫描代码工程中需要配置的,用于通过token的方式连接Sonarqube平台传数据结果&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88b8c0f4152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;安装插件&#34;&gt;安装插件&lt;/h1&gt;
&lt;p&gt;使用admin账户登陆sonar之后，在配置中点击应用市场，安装需要的插件&lt;br&gt;
常用的插件有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sonar-l10n-zh-plugin （汉化插件）&lt;/li&gt;
&lt;li&gt;sonar-android-plugin （Android代码规则）&lt;/li&gt;
&lt;li&gt;sonar-jacoco-plugin （jacoco代码覆盖率插件）&lt;/li&gt;
&lt;li&gt;sonar-java-plugin （Java代码规则插件，默认已经安装好了建议更新）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;使用sonar扫描代码&#34;&gt;使用sonar扫描代码&lt;/h1&gt;
&lt;h2 id=&#34;maven项目配置&#34;&gt;maven项目配置&lt;/h2&gt;
&lt;p&gt;直接在项目目录中运行如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn sonar:sonar   -Dsonar.host.url=http://localhost:9000   -Dsonar.login=token
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有设置权限，也可以不写后面的token&lt;br&gt;
扫描结果如下&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/03/13/5c88ba87bc46c.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;gradle项目配置&#34;&gt;gradle项目配置&lt;/h2&gt;
&lt;p&gt;gradle需要先配置下build.gradle文件，加入如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply plugin: &amp;quot;org.sonarqube&amp;quot;
    sonarqube {
        properties {
            property &amp;quot;sonar.host.url&amp;quot;, &amp;quot;http://localhost:9000&amp;quot;  //sonar管理系统地址
            property &amp;quot;sonar.login&amp;quot;, &amp;quot;admin&amp;quot; // sonar管理系统账号
            property &amp;quot;sonar.password&amp;quot;, &amp;quot;admin&amp;quot; // sonar管理系统密码
            property &amp;quot;sonar.sourceEncoding&amp;quot;, &amp;quot;UTF-8&amp;quot;  //编码格式
            property &amp;quot;sonar.surefire.reportsPath&amp;quot;, &amp;quot;build/sonar&amp;quot;  //soanr结果生成路径
            property &amp;quot;sonar.junit.reportsPath&amp;quot;, &amp;quot;build/sonar&amp;quot;  //单元测试报告生成路径
            property &amp;quot;sonar.sources&amp;quot;, &amp;quot;src/main/java&amp;quot;    //源代码路径
            property &amp;quot;sonar.projectName&amp;quot;, &amp;quot;xxxx&amp;quot;  //项目名称
            property &amp;quot;sonar.language&amp;quot;, &amp;quot;java&amp;quot;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是android多模块开发的，只想要扫描其中一个模块，则需要在该模块的build.gradle文件中单独加入如上配置&lt;br&gt;
然后如果不需要跳过单元测试，则直接运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./gradlew sonarqube 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要跳过单元测试的话，后面加上&lt;code&gt;-x test&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;nodejs项目配置&#34;&gt;nodejs项目配置&lt;/h2&gt;
&lt;p&gt;nodejs的项目，需要先用npm安装一个sonar-scanner，运行命令&lt;code&gt;npm -g install sonar-scanner &lt;/code&gt;安装。安装完成后再项目目录运行下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sonar-scanner -Dsonar.host.url=http://localhost:9000  -Dsonar.login=token
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sonar-projectproperties文件示例&#34;&gt;sonar-project.properties文件示例&lt;/h2&gt;
&lt;p&gt;可以通过编写sonar-project.properties文件，实现自定义扫描代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#----- Default SonarQube server
#sonar.host.url=http://sonar.com.cn
# 项目key
sonar.projectKey=xxxx
# 项目名称
sonar.projectName=aaaaa
# 项目版本，可以写死，也可以引用变量
sonar.projectVersion=1.0.0
# 源文件编码
sonar.sourceEncoding=UTF-8
# 源文件语言
sonar.language=java
# path to source directories (required)
# 源代码目录，如果多个使用&amp;quot;,&amp;quot;分割 例如：mode1/src/main,mode2/src/main
sonar.sources=src/main
# 单元测试目录，如果多个使用&amp;quot;,&amp;quot;分割 例如：mode1/src/test,mode2/src/test
sonar.tests=src/test
# path to project binaries (optional), for example directory of Java bytecode
# java字节码目录
sonar.binaries=target/classes
# Exclude the test source
# 忽略的目录
#sonar.exclusions=*/src/test/**/*
# 单元测试报告目录
sonar.junit.reportsPath=target/surefire-reports
# 代码覆盖率插件
sonar.java.coveragePlugin=jacoco
# jacoco.exec文件路径
sonar.jacoco.reportPath=target/coverage-reports/jacoco.exec
# 这个没搞懂，官方示例是配置成jacoco.exec文件路径
sonar.jacoco.itReportPath=target/coverage-reports/jacoco-it.exec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将该文件放入项目目录，然后运行&lt;code&gt;sonar-scanner -X&lt;/code&gt;进行代码扫描&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;常见的sonar代码扫描如上，iOS由于没有使用过，所以不知道怎么配置，看教程像是很复杂的样子。等以后接触了，再来更新。&lt;/p&gt;
">SonarQube 的安装（docker）与使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/PlU021Ndb/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%AE%89%E8%A3%85-acmesh&#34;&gt;1. 安装 &lt;strong&gt;acme.sh&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6&#34;&gt;2. 生成证书&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-http-%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E5%9C%A8%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%94%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6-%E6%9D%A5%E9%AA%8C%E8%AF%81%E4%BD%A0%E7%9A%84%E5%9F%9F%E5%90%8D%E6%89%80%E6%9C%89%E6%9D%83%E5%AE%8C%E6%88%90%E9%AA%8C%E8%AF%81-%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E4%BA%86&#34;&gt;1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-dns-%E6%96%B9%E5%BC%8F-%E5%9C%A8%E5%9F%9F%E5%90%8D%E4%B8%8A%E6%B7%BB%E5%8A%A0%E4%B8%80%E6%9D%A1-txt-%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95-%E9%AA%8C%E8%AF%81%E5%9F%9F%E5%90%8D%E6%89%80%E6%9C%89%E6%9D%83&#34;&gt;2. dns 方式, 在域名上添加一条 txt 解析记录, 验证域名所有权.&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%9F%E6%88%90%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6&#34;&gt;生成泛域名证书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%BF%AE%E6%94%B9nginx%E7%9A%84ssl%E9%85%8D%E7%BD%AE&#34;&gt;3.修改nginx的ssl配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-copy%E5%AE%89%E8%A3%85-%E8%AF%81%E4%B9%A6&#34;&gt;3. copy/安装 证书&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AA%8C%E8%AF%81%E8%AF%81%E4%B9%A6&#34;&gt;验证证书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E6%9B%B4%E6%96%B0%E8%AF%81%E4%B9%A6&#34;&gt;4. 更新证书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%9B%B4%E6%96%B0-acmesh&#34;&gt;5. 更新 acme.sh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E5%87%BA%E9%94%99%E6%80%8E%E4%B9%88%E5%8A%9E&#34;&gt;6. 出错怎么办：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;acme.sh&lt;/strong&gt; 实现了 &lt;code&gt;acme&lt;/code&gt; 协议, 可以从 letsencrypt 生成免费的证书.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;主要步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 &lt;strong&gt;acme.sh&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成证书&lt;/li&gt;
&lt;li&gt;copy 证书到 nginx/apache 或者其他服务&lt;/li&gt;
&lt;li&gt;更新证书&lt;/li&gt;
&lt;li&gt;更新 &lt;strong&gt;acme.sh&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;出错怎么办, 如何调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面详细介绍.&lt;/p&gt;
&lt;h1 id=&#34;1-安装-acmesh&#34;&gt;1. 安装 &lt;strong&gt;acme.sh&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;安装很简单, 一个命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl  https://get.acme.sh | sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;普通用户和 root 用户都可以安装使用.&lt;br&gt;
安装过程进行了以下几步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 acme.sh 安装到你的 &lt;strong&gt;home&lt;/strong&gt; 目录下:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;~/.acme.sh/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并创建 一个 bash 的 alias, 方便你的使用:  &lt;code&gt;alias acme.sh=~/.acme.sh/acme.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2). 自动为你创建 cronjob,  每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书.&lt;/p&gt;
&lt;p&gt;更高级的安装选项请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-install&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装过程不会污染已有的系统任何功能和文件&lt;/strong&gt;, 所有的修改都限制在安装目录中: &lt;code&gt;~/.acme.sh/&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-生成证书&#34;&gt;2. 生成证书&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;acme.sh&lt;/strong&gt; 实现了 &lt;strong&gt;acme&lt;/strong&gt; 协议支持的所有验证协议.&lt;br&gt;
一般有两种方式验证: http 和 dns 验证.&lt;/p&gt;
&lt;h3 id=&#34;1-http-方式需要在你的网站根目录下放置一个文件-来验证你的域名所有权完成验证-然后就可以生成证书了&#34;&gt;1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只需要指定域名, 并指定域名所在的网站根目录. &lt;strong&gt;acme.sh&lt;/strong&gt; 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用.&lt;/p&gt;
&lt;p&gt;如果你用的 &lt;strong&gt;apache&lt;/strong&gt;服务器, &lt;strong&gt;acme.sh&lt;/strong&gt; 还可以智能的从 &lt;strong&gt;apache&lt;/strong&gt;的配置中自动完成验证, 你不需要指定网站根目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --issue  -d mydomain.com   --apache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你用的 &lt;strong&gt;nginx&lt;/strong&gt;服务器, 或者反代, &lt;strong&gt;acme.sh&lt;/strong&gt; 还可以智能的从 &lt;strong&gt;nginx&lt;/strong&gt;的配置中自动完成验证, 你不需要指定网站根目录:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --issue  -d mydomain.com   --nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你还没有运行任何 web 服务, &lt;strong&gt;80&lt;/strong&gt; 端口是空闲的, 那么 &lt;strong&gt;acme.sh&lt;/strong&gt; 还能假装自己是一个webserver, 临时听在&lt;strong&gt;80&lt;/strong&gt; 端口, 完成验证:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue -d mydomain.com   --standalone
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更高级的用法请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert&lt;/p&gt;
&lt;h3 id=&#34;2-dns-方式-在域名上添加一条-txt-解析记录-验证域名所有权&#34;&gt;2. dns 方式, 在域名上添加一条 txt 解析记录, 验证域名所有权.&lt;/h3&gt;
&lt;p&gt;这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证.&lt;br&gt;
坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue  --dns   -d mydomain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, &lt;strong&gt;acme.sh&lt;/strong&gt; 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可.&lt;/p&gt;
&lt;p&gt;等待解析完成之后, 重新生成证书:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --renew   -d mydomain.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意第二次这里用的是 &lt;code&gt;--renew&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;acme.sh&lt;/strong&gt; 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.&lt;/p&gt;
&lt;p&gt;以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的.&lt;br&gt;
然后:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export DP_Id=&amp;quot;1234&amp;quot;

export DP_Key=&amp;quot;sADDsdasdgdsf&amp;quot;

acme.sh   --issue   --dns dns_dp   -d aa.com  -d www.aa.com

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了.&lt;br&gt;
直接生成就好了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue   -d  mydomain2.com   --dns  dns_dp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;阿里云的dns为：dns_ali&lt;br&gt;
腾讯/DNSPod为：dns_dp&lt;br&gt;
CloudFlare为：dns_cf&lt;/p&gt;
&lt;h4 id=&#34;生成泛域名证书&#34;&gt;生成泛域名证书&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --issue --dns dns_dp -d aaa.com -d *.aaa.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更详细的 api 用法: https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md&lt;/p&gt;
&lt;h3 id=&#34;3修改nginx的ssl配置&#34;&gt;3.修改nginx的ssl配置&lt;/h3&gt;
&lt;p&gt;运行&lt;code&gt;openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048&lt;/code&gt;生成dhparam.pem 文件&lt;/p&gt;
&lt;p&gt;修改 Nginx 启用 SSL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ssl_certificate  /etc/nginx/ssl/fullchain.cer;
    ssl_certificate_key  /etc/nginx/ssl/&amp;lt;domain&amp;gt;.key;
    ssl_session_timeout 5m;
    ssl_session_cache shared:SSL:1m;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_dhparam  /etc/nginx/ssl/dhparam.pem;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-copy安装-证书&#34;&gt;3. copy/安装 证书&lt;/h1&gt;
&lt;p&gt;前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.&lt;/p&gt;
&lt;p&gt;注意, 默认生成的证书都放在安装目录下: &lt;code&gt;~/.acme.sh/&lt;/code&gt;,  请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.&lt;/p&gt;
&lt;p&gt;正确的使用方法是使用 &lt;code&gt;--installcert&lt;/code&gt; 命令,并指定目标位置, 然后证书文件会被copy到相应的位置,&lt;br&gt;
例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --installcert  -d  &amp;lt;domain&amp;gt;.com   \
        --key-file   /etc/nginx/ssl/&amp;lt;domain&amp;gt;.key \
        --fullchain-file /etc/nginx/ssl/fullchain.cer \
        --reloadcmd  &amp;quot;service nginx force-reload&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于泛域名使用下面命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --installcert  -d &amp;lt;domain&amp;gt;.com -d *.&amp;lt;domain&amp;gt;.com   \
        --key-file  /etc/nginx/ssl/&amp;lt;domain&amp;gt;.com.key \
        --fullchain-file /etc/nginx/ssl/fullchain.cer \
        --reloadcmd  &amp;quot;service nginx force-reload&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(一个小提醒, 这里用的是 &lt;code&gt;service nginx force-reload&lt;/code&gt;, 不是 &lt;code&gt;service nginx reload&lt;/code&gt;, 据测试, &lt;code&gt;reload&lt;/code&gt; 并不会重新加载证书, 所以用的 &lt;code&gt;force-reload&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Nginx 的配置 &lt;code&gt;ssl_certificate&lt;/code&gt; 使用 &lt;code&gt;/etc/nginx/ssl/fullchain.cer&lt;/code&gt; ，而非 &lt;code&gt;/etc/nginx/ssl/&amp;lt;domain&amp;gt;.cer&lt;/code&gt; ，否则 &lt;a href=&#34;https://www.ssllabs.com/ssltest/&#34;&gt;SSL Labs&lt;/a&gt; 的测试会报 &lt;code&gt;Chain issues Incomplete&lt;/code&gt; 错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--installcert&lt;/code&gt;命令可以携带很多参数, 来指定目标文件.  并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效.&lt;/p&gt;
&lt;p&gt;详细参数请参考: https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc&lt;/p&gt;
&lt;p&gt;值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用.&lt;/p&gt;
&lt;h2 id=&#34;验证证书&#34;&gt;验证证书&lt;/h2&gt;
&lt;p&gt;访问 ssllabs.com 输入你的域名，检查 SSL 的配置是否都正常：&lt;br&gt;
https://ssllabs.com/ssltest/analyze.html?d=xxx.com&lt;br&gt;
确保验证结果有 A 以上，否则根据提示调整问题&lt;/p&gt;
&lt;h1 id=&#34;4-更新证书&#34;&gt;4. 更新证书&lt;/h1&gt;
&lt;p&gt;目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心.&lt;/p&gt;
&lt;h1 id=&#34;5-更新-acmesh&#34;&gt;5. 更新 acme.sh&lt;/h1&gt;
&lt;p&gt;目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步.&lt;/p&gt;
&lt;p&gt;升级 acme.sh 到最新版 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你不想手动升级, 可以开启自动升级:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --upgrade  --auto-upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后, acme.sh 就会自动保持更新了.&lt;/p&gt;
&lt;p&gt;你也可以随时关闭自动更新:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh --upgrade  --auto-upgrade  0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-出错怎么办&#34;&gt;6. 出错怎么办：&lt;/h1&gt;
&lt;p&gt;如果出错, 请添加 debug log：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue  .....  --debug 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acme.sh  --issue  .....  --debug  2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请参考： https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh&lt;/p&gt;
">acme自动签发HTTPS证书--摘录官方wiki</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/48t-QeAvo/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#metricbeat-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;metricbeat 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#filebeat-%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86&#34;&gt;filebeat 日志收集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;docker 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;docker 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;MYSQL 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mysql-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;MYSQL 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7&#34;&gt;MYSQL 日志监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;redis 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#redis-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;redis 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#redis-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7&#34;&gt;redis 日志监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;nginx 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nginx-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;nginx 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7&#34;&gt;nginx 日志监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;系统性能配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;系统性能监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#postgresql-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;postgresql 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#postgresql-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;postgresql 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#postgresql-%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7&#34;&gt;postgresql 日志监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rabbitmq-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;rabbitmq 配置文件&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rabbitmq-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7&#34;&gt;rabbitmq 性能监控&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
以下为ELK常见配置的中文说明，具体配置再安装完ELK的客户端之后，再配置文件中自行修改。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;metricbeat-性能监控&#34;&gt;metricbeat 性能监控&lt;/h2&gt;
&lt;p&gt;在 linux 系统中，编辑/etc/metricbeat/modules.d/ 目录下对应的开源组件配置文件&lt;br&gt;
在 Windows 系统中，编辑/metricbeat/modules.d/ 目录下对应的开源组件配置文件&lt;br&gt;
编辑配置文件之后，需要重启 metricbeat 才会生效&lt;/p&gt;
&lt;h2 id=&#34;filebeat-日志收集&#34;&gt;filebeat 日志收集&lt;/h2&gt;
&lt;p&gt;在 linux 系统中，编辑/etc/filebeat/modules.d/ 目录下对应的开源组件配置文件&lt;br&gt;
在 Windows 系统中，编辑/filebeat/modules.d/ 目录下对应的开源组件配置文件&lt;br&gt;
编辑配置文件之后，需要重启 filebeat 才会生效&lt;/p&gt;
&lt;h2 id=&#34;docker-配置文件&#34;&gt;docker 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;docker-性能监控&#34;&gt;docker 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#docker监控的指标，和docker的地址，通常默认即可，如果不需要监控某些指标，可以用#号注释
metricbeat.modules:
- module: docker
  metricsets:
    - &amp;quot;container&amp;quot;
    - &amp;quot;cpu&amp;quot;
    - &amp;quot;diskio&amp;quot;
    - &amp;quot;healthcheck&amp;quot;
    - &amp;quot;info&amp;quot;
    #- &amp;quot;image&amp;quot;
    - &amp;quot;memory&amp;quot;
    - &amp;quot;network&amp;quot;
  hosts: [&amp;quot;unix:///var/run/docker.sock&amp;quot;]
#
  period: 10s
  enabled: true

  # If set to true, replace dots in labels with `_`.
  #labels.dedot: false

  # 如果docker开启了SSL认证，需要加入对应的证书位置，通常不需要。
  #ssl:
    #certificate_authority: &amp;quot;/etc/pki/root/ca.pem&amp;quot;
    #certificate:           &amp;quot;/etc/pki/client/cert.pem&amp;quot;
    #key:                   &amp;quot;/etc/pki/client/cert.key&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mysql-配置文件&#34;&gt;MYSQL 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;mysql-性能监控&#34;&gt;MYSQL 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#mysql监控的指标和数据上报时间的设置
metricbeat.modules:
- module: mysql
  metricsets:
    - &amp;quot;status&amp;quot;
  #  - &amp;quot;galera_status&amp;quot;
  period: 10s

 #设置数据库连接，按照下面例子进行修改  &amp;quot;用户名:密码@tcp(数据库地址:数据库端口)/&amp;quot;
  hosts: [&amp;quot;root:secret@tcp(127.0.0.1:3306)/&amp;quot;]

  # By setting raw to true, all raw fields from the status metricset will be added to the event.
  #raw: false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mysql-日志监控&#34;&gt;MYSQL 日志监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- module: mysql
  #错误日志
  error:
    enabled: true

    # 设置日志的地址，如果不设置，会根据系统自动找默认的日志地址
    #var.paths:

  # 慢日志
  slowlog:
    enabled: true

    # 设置日志的地址，如果不设置，会根据系统自动找默认的日志地址
    #var.paths:

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redis-配置文件&#34;&gt;redis 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;redis-性能监控&#34;&gt;redis 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#redis监控的指标，包括数据上报的间隔
metricbeat.modules:
- module: redis
  metricsets: [&amp;quot;info&amp;quot;, &amp;quot;keyspace&amp;quot;]
  enabled: true
  period: 10s

  # redis的地址
  hosts: [&amp;quot;127.0.0.1:6379&amp;quot;]

  #  datacenter: west

  # 链接redis的方式，默认是tcp，不需要修改
  #network: tcp

  # redis密码认证，如果加了密码，需要修改
  #password: foobared

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;redis-日志监控&#34;&gt;redis 日志监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- module: redis
  # Main logs
  log:
    enabled: true

    #  设置日志的地址，如果不设置，会根据系统自动找默认的日志地址
    #var.paths: [&amp;quot;/var/log/redis/redis-server.log*&amp;quot;]

  # 慢日志的收集，需要通过API连接redis
  slowlog:
    enabled: true

    # 设置redis的连接
    #var.hosts: [&amp;quot;localhost:6379&amp;quot;]

    # 设置redis的密码，如果没有可以不设置
    #var.password:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginx-配置文件&#34;&gt;nginx 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;nginx-性能监控&#34;&gt;nginx 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#nginx的监控设置，需要在nginx开启性能页面，具体见nginx配置说明中的开启nginx状态监控
metricbeat.modules:
- module: nginx
  metricsets: [&amp;quot;stubstatus&amp;quot;]
  enabled: true
  period: 10s

  # nginx的地址
  hosts: [&amp;quot;http://127.0.0.1&amp;quot;]

  # status的地址，如果nginx的状态页面是 http://127.0.0.1/server-status 则配置如下，IP和端口填在上面的host里面，后面的path填下面这里
  server_status_path: &amp;quot;server-status&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;nginx-日志监控&#34;&gt;nginx 日志监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- module: nginx
  # 收集成功日志
  access:
    enabled: true

    # 设置成功日志的地址，如果不设置，会根据系统自动找默认的日志地址
    #var.paths:

  # 收集错误日志
  error:
    enabled: true

    # 设置错误日志的地址，如果不设置，会根据系统自动找默认的日志地址
    #var.paths:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;系统性能配置文件&#34;&gt;系统性能配置文件&lt;/h2&gt;
&lt;h4 id=&#34;系统性能监控&#34;&gt;系统性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#系统的相关指标和数据上报时间间隔，不监控的用#号注释
metricbeat.modules:
- module: system
  metricsets:
    - cpu             # CPU usage
    - load            # CPU load averages
    - memory          # Memory usage
    - network         # Network IO
    - process         # Per process metrics
    - process_summary # Process summary
    - uptime          # System Uptime
    #- core           # Per CPU core usage
    #- diskio         # Disk IO
    #- filesystem     # File system usage for each mountpoint
    #- fsstat         # File system summary metrics
    #- raid           # Raid
    #- socket         # Sockets and connection info (linux only)
  enabled: true
  period: 10s
  processes: [&#39;.*&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;postgresql-配置文件&#34;&gt;postgresql 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;postgresql-性能监控&#34;&gt;postgresql 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#postgresql的地址
- module: postgresql
  hosts: [&amp;quot;postgres://localhost:5432&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;postgresql-日志监控&#34;&gt;postgresql 日志监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;- module: postgresql
  # 开启日志
  log:
    enabled: true

    # 设置日志的位置
    #var.paths:
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;rabbitmq-配置文件&#34;&gt;rabbitmq 配置文件&lt;/h2&gt;
&lt;h4 id=&#34;rabbitmq-性能监控&#34;&gt;rabbitmq 性能监控&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;
#rabbitmq的地址
- module: rabbitmq
  hosts: [&amp;quot;localhost:15672&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;
">ELK Metricbeat配置文件的修改</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/WTAZgiW86/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#windows%E7%AF%87&#34;&gt;Windows篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux%E7%AF%87&#34;&gt;Linux篇&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC&#34;&gt;一键安装脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85metricbeatfilebeat%E6%9B%BF%E6%8D%A2%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84metricbeat%E5%8D%B3%E5%8F%AF&#34;&gt;手动安装metricbeat（filebeat替换下面代码中的metricbeat即可）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%BE%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;编辑配置文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9&#34;&gt;部署注意事项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&#34;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
ELK其他组件部署与此类似，可以对照这进行安装&lt;/p&gt;
&lt;h2 id=&#34;windows篇&#34;&gt;Windows篇&lt;/h2&gt;
&lt;p&gt;选择系统指标后，下面会显示安装教程。下面说明Windows的安装（页面可以用浏览器自带的翻译功能翻译英文，便于理解）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载Windows监控程序的安装包Metricbeat Windows zip文件，W&lt;/li&gt;
&lt;li&gt;indows选择64位的&lt;/li&gt;
&lt;li&gt;将下载的文件解压到&lt;code&gt;C:\Program Files&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将解压出来的文件重命名为Metricbeat&lt;/li&gt;
&lt;li&gt;右键&lt;code&gt;install-service-metricbeat.ps1&lt;/code&gt;文件，选择以PowerShell运行（需要有管理员权限）或者直接双击打开&lt;/li&gt;
&lt;li&gt;编辑&lt;code&gt;metricbeat.yml&lt;/code&gt;文件，找到&lt;code&gt;output.elasticsearch: &lt;/code&gt;将下面的&lt;code&gt;hosts: [&amp;quot;localhost:9200&amp;quot;]&lt;/code&gt;修改为&lt;code&gt;hosts: [&amp;quot;ELK_HOST:9200&amp;quot;]&lt;/code&gt;。在General项里面找到被注释的&lt;code&gt;name：&lt;/code&gt; 取消注释，在冒号后加一个空格，然后输入该监控服务器的名称，例如gfmysql230。一般为项目+IP，然后保存文件&lt;/li&gt;
&lt;li&gt;编辑&lt;code&gt;modules.d/system.yml&lt;/code&gt;文件（如果需要监控如nginx这些则需要编辑对应文件，且删除文件名后面的.disabled），在第二行加入&lt;code&gt;period: 5s&lt;/code&gt;（需要注意对齐，该命令的含义为每5s上报一次数据，如果不加则默认为每10秒上报一次，性能测试有要求的情况可以修改为1s）&lt;/li&gt;
&lt;li&gt;打开任务管理器，选择服务，找到metricbeat服务，点击运行。如果没有服务，则为第四步执行有问题，可能没有管理员权限。运行成功后任务管理器会显示pid&lt;/li&gt;
&lt;li&gt;打开监控平台，搜索刚才设置的name名称。搜索方法如下&lt;code&gt;beat.name:230gfmysql&lt;/code&gt;（name为具体自己设置的）.时间选择最近15分钟，如果出现数据，则表示监控已经成功部署&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;linux篇&#34;&gt;Linux篇&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;安装完成后需要自己修改配置文件，修改方法参考见 ELK常用组件配置 和下面的修改配置文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;一键安装脚本&#34;&gt;一键安装脚本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;wget https://qcloud.coding.net/u/lm93129/p/mysave/git/raw/master/myshell.sh &amp;amp;&amp;amp; bash myshell.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;手动安装metricbeatfilebeat替换下面代码中的metricbeat即可&#34;&gt;手动安装metricbeat（filebeat替换下面代码中的metricbeat即可）&lt;/h4&gt;
&lt;p&gt;rpm包使用的是我自己存在coding上的rpm，如果需要最新的，可以自己去ELK的官网下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -L -O https://qcloud.coding.net/u/lm93129/p/mysave/git/raw/master/rpm/metricbeat-6.4.1-x86_64.rpm
sudo rpm -vi metricbeat-6.4.1-x86_64.rpm 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;编辑配置文件&#34;&gt;编辑配置文件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编辑&lt;code&gt;/etc/metricbeat/metricbeat.yml&lt;/code&gt;文件（可以用vi命令）。具体编辑内容见Windows篇。需要编辑的内容是一样的&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;sudo metricbeat modules enable system&lt;/code&gt;启用系统监控，然后编辑&lt;code&gt;/etc/metricbeat/modules.d/system.yml&lt;/code&gt;文件，修改内容和Windows一样。&lt;/li&gt;
&lt;li&gt;如果需要启用其他监控，将第三步中的命令修改下即可，如需要监控nginx，则输入&lt;code&gt;sudo metricbeat modules enable nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;sudo service metricbeat start&lt;/code&gt;启动服务。请勿输入&lt;code&gt;sudo metricbeat setup&lt;/code&gt;建立仪表盘（仪表盘均已建立）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;部署注意事项&#34;&gt;部署注意事项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;时区为北京时间，且必须同步。Linux下，查看服务器当前时间命令为date&lt;/li&gt;
&lt;li&gt;名称必须为互相不冲突且简单易懂。&lt;/li&gt;
&lt;li&gt;监控项的配置文件中的名称，也必须对应设定。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#启动监控
service metricbeat start
#重启监控 
service metricbeat restart
#查看监控状态
service metricbeat status
#关闭监控
service metricbeat stop
&lt;/code&gt;&lt;/pre&gt;
">ELK的Metricbeat性能监控组件部署方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/gTgj2fXew/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E7%AE%80%E4%BB%8B&#34;&gt;Appium 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E4%BC%98%E5%8A%BF&#34;&gt;Appium 优势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86&#34;&gt;Appium 架构原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86&#34;&gt;运行原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;Appium 服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bootstrapjar&#34;&gt;Bootstrap.jar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E5%AE%A2%E6%88%B7%E7%AB%AF&#34;&gt;Appium 客户端&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E7%BB%84%E4%BB%B6&#34;&gt;Appium 组件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#appium-server&#34;&gt;Appium Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-desktop&#34;&gt;Appium Desktop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85-appium&#34;&gt;安装 appium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1%E5%AE%89%E8%A3%85-java-%E7%8E%AF%E5%A2%83&#34;&gt;1.安装 Java 环境&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%88%E4%BB%8E-java-%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD-jdk%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E5%B9%B6%E4%B8%94%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%9C%A8-cmd-%E4%B8%AD%E8%BE%93%E5%85%A5-java-version-%E7%A1%AE%E8%AE%A4-java-%E7%89%88%E6%9C%AC%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84-java-7-%E6%88%96%E8%80%85-java-8-%E9%83%BD%E5%8F%AF%E4%BB%A5&#34;&gt;先从 Java 官网下载 jdk，正确安装并且配置环境变量，在 cmd 中输入 java -version 确认 java 版本，目前最新的 java 7 或者 Java 8 都可以&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E5%AE%89%E8%A3%85-android-jdk&#34;&gt;2.安装 android jdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%BD%BF%E7%94%A8-appium-%E5%AE%89%E8%A3%85%E5%8C%85&#34;&gt;3.使用 Appium 安装包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-capability-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%AE%80%E4%BB%8B&#34;&gt;appium capability 参数配置简介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AF-capability&#34;&gt;什么是 Capability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#session&#34;&gt;Session&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8-capability-%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3&#34;&gt;常用 Capability 配置讲解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E7%94%A8-capability&#34;&gt;公用 Capability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#android-%E7%8B%AC%E6%9C%89-capability&#34;&gt;Android 独有 Capability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ios-%E7%8B%AC%E6%9C%89-capability&#34;&gt;ios 独有 Capability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#desired-capability-%E5%8F%82%E6%95%B0-josin&#34;&gt;desired capability 参数 Josin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inspector-%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96&#34;&gt;Inspector 元素获取&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%8E%B7%E5%8F%96-apppackage-%E5%92%8C-appactivity&#34;&gt;获取 appPackage 和 appActivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95-1&#34;&gt;方法 1:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95-2&#34;&gt;方法 2:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95-3&#34;&gt;方法 3:&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A6%96%E5%85%88%E4%BD%A0%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA-app-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8C%85-xxxapk&#34;&gt;首先，你要有一个 APP 的安装包 xxx.apk，&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95-4&#34;&gt;方法 4:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D&#34;&gt;appium 元素定位&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F&#34;&gt;元素定位方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#id-%E5%AE%9A%E4%BD%8D&#34;&gt;id 定位&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF-%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86&#34;&gt;测试场景--自动登陆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#name-%E5%AE%9A%E4%BD%8D&#34;&gt;name 定位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#classname-%E5%AE%9A%E4%BD%8D&#34;&gt;classname 定位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#xpath-%E5%AE%9A%E4%BD%8D&#34;&gt;xpath 定位&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B&#34;&gt;实践案例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-%E4%B9%8B-toast-%E5%85%83%E7%B4%A0%E8%AF%86%E5%88%AB&#34;&gt;appium 之 Toast 元素识别&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83&#34;&gt;问题思考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#toast-%E7%AE%80%E4%BB%8B&#34;&gt;Toast 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appium-toast-%E5%86%85%E5%AE%B9%E8%8E%B7%E5%8F%96&#34;&gt;Appium Toast 内容获取&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF&#34;&gt;测试场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0&#34;&gt;代码实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B3%A8%E6%84%8Ftoast-%E5%86%85%E5%AE%B9%E4%B8%BA%E4%B8%AD%E6%96%87%E6%97%B6%E9%A1%B6%E9%83%A8%E5%BF%85%E9%A1%BB%E6%B3%A8%E9%87%8A-codingutf-8-%E5%90%A6%E5%88%99%E4%BC%9A%E5%9B%A0%E4%B8%BA%E7%BC%96%E8%A7%A3%E7%A0%81%E5%AF%BC%E8%87%B4%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB%E5%A4%B1%E8%B4%A5&#34;&gt;&lt;strong&gt;注意：Toast 内容为中文时，顶部必须注释# coding=utf-8 否则会因为编解码导致文字识别失败。&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;appium-简介&#34;&gt;Appium 简介&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;Appium 是一个开源测试自动化框架，可用于原生，混合和移动 Web 应用程序测试。&lt;br&gt;
它使用 WebDriver 协议驱动 iOS，Android 和 Windows 应用程序。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;appium-优势&#34;&gt;Appium 优势&lt;/h1&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;可以跨平台同时支持 android、ios&lt;/li&gt;
&lt;li&gt;支持多种语言，java、python、php、Ruby 等等&lt;/li&gt;
&lt;li&gt;不用为复杂的环境发愁&lt;/li&gt;
&lt;li&gt;如果你有 selenium 经验，直接上手。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;appium-架构原理&#34;&gt;Appium 架构原理&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;Appium 是在手机操作系统自带的测试框架基础上实现的，Android 和 iOS 的系统上使用的工具分别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android（版本&amp;gt;4.3）：UIAutomator，Android 4.3 之后系统自带的 UI 自动化测试工具。&lt;/li&gt;
&lt;li&gt;Android（版本 ≤4.3）：Selendroid，基于 Android Instrumentation 框架实现的自动化测试工具。&lt;/li&gt;
&lt;li&gt;iOS：UIAutomation（instruments 框架里面的一个模板），iOS 系统自带的 UI 自动化测试工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d6f170674.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;运行原理&#34;&gt;运行原理&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;我们的电脑（client）上运行自动化测试脚本，调用的是 webdriver 的接口，appium server 接收到我们 client 上发送过来的命令后他会将这些命令转换为 UIautomator 认识的命令，然后由 UIautomator 来在设备上执行自动化。&lt;/p&gt;
&lt;p&gt;Appium 的架构原理如上图所示，由客户端（Appium Client）和服务器（Appium Server）两部分组成，客户端与服务器端通过 JSON Wire Protocol 进行通信。&lt;/p&gt;
&lt;h2 id=&#34;appium-服务器&#34;&gt;Appium 服务器&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Appium 服务器是 Appium 框架的核心。它是一个基于 Node.js 实现的 HTTP 服务器。Appium 服务器的主要功能是接受从 Appium 客户端发起的连接，监听从客户端发送来的命令，将命令发送给 bootstrap.jar（iOS 手机为 bootstrap.js）执行，并将命令的执行结果通过 HTTP 应答反馈给 Appium 客户端。&lt;/p&gt;
&lt;h2 id=&#34;bootstrapjar&#34;&gt;Bootstrap.jar&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Bootstrap.jar 是在 Android 手机上运行的一个应用程序，它在手机上扮演 TCP 服务器的角色。当 Appium 服务器需要运行命令时，Appium 服务器会与 Bootstrap.jar 建立 TCP 通信，并把命令发送给 Bootstrap.jar；Bootstrap.jar 负责运行测试命令。&lt;/p&gt;
&lt;h2 id=&#34;appium-客户端&#34;&gt;Appium 客户端&lt;/h2&gt;
&lt;p&gt;它主要是指实现了 Appium 功能的 WebDriver 协议的客户端 Library，它负责与 Appium 服务器建立连接，并将测试脚本的指令发送到 Appium 服务器。现有的客户端 Library 有多种语言的实现，包括 Ruby、Python、Java、JavaScript（Node.js）、Object C、PHP 和 C#。Appium 的测试是在这些 Library 的基础上进行开发的。&lt;/p&gt;
&lt;h1 id=&#34;appium-组件&#34;&gt;Appium 组件&lt;/h1&gt;
&lt;h2 id=&#34;appium-server&#34;&gt;Appium Server&lt;/h2&gt;
&lt;p&gt;Appium Server 就是 Appium 的服务端——一个 web 接口服务&lt;/p&gt;
&lt;h2 id=&#34;appium-desktop&#34;&gt;Appium Desktop&lt;/h2&gt;
&lt;p&gt;Appium Desktop 是一款适用于 Mac，Windows 和 Linux 的开源应用程序，它以美观而灵活的用户界面为您提供 Appium 自动化服务器的强大功能。 它是几个 Appium 相关工具的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Appium Server 的图形界面。 您可以设置选项，启动/停止服务器，查看日志等…您也不需要使用 Node 的 NPM 来安装 Appium，因为 Node 运行时与 Appium Desktop 捆绑在一起。&lt;/li&gt;
&lt;li&gt;您可以使用 Inspector 查看应用程序的元素，获取有关它们的基本信息，并与它们进行基本的交互。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d70c9874f.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;安装-appium&#34;&gt;安装 appium&lt;/h1&gt;
&lt;h1 id=&#34;1安装-java-环境&#34;&gt;1.安装 Java 环境&lt;/h1&gt;
&lt;h3 id=&#34;先从-java-官网下载-jdk正确安装并且配置环境变量在-cmd-中输入-java-version-确认-java-版本目前最新的-java-7-或者-java-8-都可以&#34;&gt;先从 Java 官网下载 jdk，正确安装并且配置环境变量，在 cmd 中输入 java -version 确认 java 版本，目前最新的 java 7 或者 Java 8 都可以&lt;/h3&gt;
&lt;h1 id=&#34;2安装-android-jdk&#34;&gt;2.安装 android jdk&lt;/h1&gt;
&lt;p&gt;目前&lt;a href=&#34;https://developer.android.com/&#34;&gt;官网&lt;/a&gt;推荐的做法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 Android Studio （包含 Android SDK） – 推荐&lt;/li&gt;
&lt;li&gt;仅安装 Android SDK 命令行工具&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新版本的 Android SDK 和以前也不太一样，以前我们有一个 SDK Manager.exe 的工具用于更新和下载各版本的 API，还有一个 AVD Manager.exe 的工具可以模拟各种型号的安卓设备。最新的 SDK 工具把 UI 界面基本都去掉了，只留下命令行工具，具体的使用可以参阅官方文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/studio/releases/sdk-tools.html&#34;&gt;https://developer.android.com/studio/releases/sdk-tools.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载完成后打开 sdk manager.exe，选择 tools，配置国内镜像源&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d7343cf5b.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里推荐使用的源如下：&lt;/p&gt;
&lt;p&gt;1、东软信息学院&lt;br&gt;
mirrors.neusoft.edu.cn 端口：80&lt;br&gt;
2、北京化工大学&lt;br&gt;
ubuntu.buct.edu.cn/ubuntu.buct.cn 端口：80&lt;br&gt;
3、电子科技大学&lt;/p&gt;
&lt;p&gt;mirrors.dormforce.net 端口：80&lt;/p&gt;
&lt;p&gt;其中，强烈推荐电子科技大学的镜像源！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d7426ecf7.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后选择要安装的 android 版本 ，这里推荐安装 api 26，其他默认安装即可。&lt;/p&gt;
&lt;p&gt;安装完成后需要配置 android home 环境变量，下面设置环境变量：&lt;/p&gt;
&lt;p&gt;“我的电脑” 右键菜单 —&amp;gt; 属性 —&amp;gt; 高级 —&amp;gt; 环境变量 —&amp;gt; 系统变量 —&amp;gt; 新建…&lt;/p&gt;
&lt;p&gt;变量名为：ANDROID_HOME 变量值为 sdk 的目录&lt;br&gt;
添加全局变量，找到 path 变量名—&amp;gt; “编辑” 添加：%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools;&lt;/p&gt;
&lt;p&gt;注：path 变量的添加，如果最后有；号，则添加的时候，就不需要重复添加。如果没有，则需要自己先加一个；号再输入上面的变量&lt;/p&gt;
&lt;h1 id=&#34;3使用-appium-安装包&#34;&gt;3.使用 Appium 安装包&lt;/h1&gt;
&lt;p&gt;从官网下载，Appium 目前托管在 github，正确的下载地址应该为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/appium/appium-desktop/releases&#34;&gt;https://github.com/appium/appium-desktop/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般是下载最新的版本，目前版本是 1.8.2。安装完成后直接打开就可以了。&lt;/p&gt;
&lt;h1 id=&#34;appium-capability-参数配置简介&#34;&gt;appium capability 参数配置简介&lt;/h1&gt;
&lt;h2 id=&#34;什么是-capability&#34;&gt;什么是 Capability&lt;/h2&gt;
&lt;p&gt;desired capability 的功能是配置 Appium 会话。他们告诉 Appium 服务器您想要自动化的平台和应用程序。&lt;/p&gt;
&lt;p&gt;Desired Capabilities 是一组设置的键值对的集合，其中键对应设置的名称，而值对应设置的值。（如：”platformName”: “Android”）Desired Capabilities 主要用于通知 Appium 服务器建立需要的 Session。&lt;/p&gt;
&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;
&lt;p&gt;Appium 的客户端和服务端之间进行通信都必须在一个 Session 的上下文中进行。客户端在发起通信的时候首先会发送一个叫作“Desired Capabilities”的 JSON 对象给服务器。服务器收到该数据后，会创建一个 session 并将 session 的 ID 返回到客户端。之后客户端可以用该 session 的 ID 发送后续的命令。&lt;/p&gt;
&lt;h2 id=&#34;常用-capability-配置讲解&#34;&gt;常用 Capability 配置讲解&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://appium.io/docs/cn/writing-running-appium/caps/#android&#34;&gt;Capability 官方完整文档&lt;/a&gt;&lt;br&gt;
他主要分成了三部分：公共部分、ios 部分、android 部分，如果你 android 想用 ios 的那是不可能的，so，老老实实去了解每个平台有哪些，他们的作用是什么。下面我们介绍一些公用常用的,红色标记的为常用的选项。&lt;/p&gt;
&lt;h3 id=&#34;公用-capability&#34;&gt;公用 Capability&lt;/h3&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d756c88fd.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;android-独有-capability&#34;&gt;Android 独有 Capability&lt;/h3&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d76717fac.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;ios-独有-capability&#34;&gt;ios 独有 Capability&lt;/h3&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d777ee150.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;desired-capability-参数-josin&#34;&gt;desired capability 参数 Josin&lt;/h3&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;platformName&amp;quot;: &amp;quot;Android&amp;quot;,
  &amp;quot;platformVersion&amp;quot;: &amp;quot;5.1.1&amp;quot;,
  &amp;quot;deviceName&amp;quot;: &amp;quot;127.0.0.1:62025&amp;quot;,
  &amp;quot;appPackage&amp;quot;: &amp;quot;com.tal.kaoyan&amp;quot;,
  &amp;quot;appActivity&amp;quot;: &amp;quot;com.tal.kaoyan.ui.activity.SplashActivity&amp;quot;,
  &amp;quot;noReset&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d78b07020.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;新的会话窗口允许您构造一组 desired capabilities，用于启动 Appium 会话。您可以针对当前运行的 Appium Desktop 服务器(默认的)启动一个会话，或者您可以针对各种其他端点启动一个会话。&lt;/p&gt;
&lt;p&gt;因为不需要使用 Appium Desktop 自己的服务器，您可以在不启动 Appium Desktop 服务器的情况下进入新的会话窗口。只需点击“File”(Windows / Linux)或“Appium”(Mac)，然后选择“New Session…”，它将打开新的会话窗口，而不必启动本地服务器。在这种情况下，将禁用附加到本地服务器。&lt;/p&gt;
&lt;h3 id=&#34;inspector-元素获取&#34;&gt;Inspector 元素获取&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;启动成功之后就可以使用 Inspector 来进行元素空间获取了。&lt;br&gt;
注意：默认的元素定位有一些不准，需要切换到第二个坐标点定位选项后再切换回来才能准确定位。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d79da340d.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;获取-apppackage-和-appactivity&#34;&gt;获取 appPackage 和 appActivity&lt;/h1&gt;
&lt;p&gt;appPackage 和 appActivity 进行 appium 自动化测试非常重要的两个参数，我们所测试的 APP 不同，这两个参数肯定也是不一样的。那如何快速的获取这 APP 的这两个参数呢？下面介绍几个方法&lt;/p&gt;
&lt;h1 id=&#34;方法-1&#34;&gt;方法 1:&lt;/h1&gt;
&lt;p&gt;前提是先打开手机中你要获取包名的 APP&lt;/p&gt;
&lt;p&gt;打开命令行界面，输入：&lt;code&gt;adb shell&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后再输入&lt;code&gt;dumpsys activity | grep mFocusedActivity&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d7ad200da.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;方法-2&#34;&gt;方法 2:&lt;/h1&gt;
&lt;p&gt;这种方法也比较简单，主要针对你没有.apk 包的情况，比如 Android 原生自带的 APP（计算器、通讯录、短信...），可以通过 adb 命令。&lt;/p&gt;
&lt;p&gt;1，打开 APP。&lt;/p&gt;
&lt;p&gt;2，执行&amp;gt; adb logcat&amp;gt;D:/log.txt&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d7bc4deae.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3， 胡乱的对 APP 做一些操作。&lt;/p&gt;
&lt;p&gt;4， Ctrl+c 结束 adb 命令。&lt;/p&gt;
&lt;p&gt;5， 打开 log.txt 文件，搜索：Displayed&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/03/07/5c80d7c84d8a9.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;appPackage: com.android.messaging&lt;/p&gt;
&lt;p&gt;appActivity：.ui.conversationlist.ConversationListActivity&lt;/p&gt;
&lt;h1 id=&#34;方法-3&#34;&gt;方法 3:&lt;/h1&gt;
&lt;h3 id=&#34;首先你要有一个-app-的安装包-xxxapk&#34;&gt;首先，你要有一个 APP 的安装包 xxx.apk，&lt;/h3&gt;
&lt;p&gt;然后，通过这个解压工具将.apk 解压。打开解压后的文件夹，找到 AndroidManifest.xml 文件，用 notepad++工具打开。在里面搜索：manifest 对应的就是 appPackage。搜索：activity 对应的就是 appActivity。（activity 关键字很多，你要注意辨别。）&lt;/p&gt;
&lt;h1 id=&#34;方法-4&#34;&gt;方法 4:&lt;/h1&gt;
&lt;p&gt;使用 python 程序自动解析，具体见自动化脚本&lt;/p&gt;
&lt;h1 id=&#34;appium-元素定位&#34;&gt;appium 元素定位&lt;/h1&gt;
&lt;p&gt;与 Web 自动化测试一样，app 自动化测试过程中最重要一个环节就是元素定位，只有准确定位到了元素才能进行相关元素的操作，如输入、点击、拖拽、滑动等。appium 提供了许多元素定位的方法，如 id 定位、name 定位、class 定位、层级定位等等…. 接下来将会给大家来实践运用这些定位技巧。&lt;/p&gt;
&lt;h2 id=&#34;元素定位方式&#34;&gt;元素定位方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;List 定位&lt;/li&gt;
&lt;li&gt;相对定位&lt;/li&gt;
&lt;li&gt;Xpath 定位&lt;/li&gt;
&lt;li&gt;H5 页面元素定位&lt;/li&gt;
&lt;li&gt;Uiautomator 定位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;id-定位&#34;&gt;id 定位&lt;/h2&gt;
&lt;p&gt;日常生活中身边可能存在相同名字的人，但是每个人的身份证号码是唯一的，在 app 界面元素中也可以使用 id 值来区分不同的元素，然后进行定位操作。Appium 中可以使用 find_element_by_id() 方法来进行 id 定位。&lt;/p&gt;
&lt;h3 id=&#34;测试场景-自动登陆&#34;&gt;测试场景--自动登陆&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;启动 App，进入到登录界面&lt;/li&gt;
&lt;li&gt;在登录页面输入用户名“ceshi”，密码‘123456’ 然后点击登录。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;driver.find_element_by_id(&#39;com.c503.module.chemicalindustrypack:id/tv_account&#39;).send_keys(&amp;quot;123456&amp;quot;)
driver.find_element_by_id(&#39;com.c503.module.chemicalindustrypack:id/tv_password&#39;).send_keys(&amp;quot;123456&amp;quot;)
driver.find_element_by_id(&#39;com.c503.module.chemicalindustrypack:id/btn_login_in&#39;).click()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;name-定位&#34;&gt;name 定位&lt;/h2&gt;
&lt;p&gt;根据 name 进行定位，对于 android 来说，就是 text 属性&lt;br&gt;
用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;driver.find_element_by_name(&#39;请输入用户名&#39;).send_keys(&#39;ceshi&#39;)
driver.find_element_by_name(&#39;登录&#39;).click()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：由于 text 稳定性不是很好，所以 appium 1.5 开始废弃了该方法。&lt;/p&gt;
&lt;h2 id=&#34;classname-定位&#34;&gt;classname 定位&lt;/h2&gt;
&lt;p&gt;classname 定位是根据元素类型来进行定位，但是实际情况中很多元素的 classname 都是相同的，&lt;/p&gt;
&lt;p&gt;如上例中登录页面中的用户名和密码都是 clasName 属性值都是：“android.widget.EditText” 因此只能定位第一个元素也就是用户名，而密码输入框就需要使用其他方式来定位，这样其实很鸡肋.一般情况下如果有 id 就不必使用 classname 定位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;driver.find_element_by_class_name(&#39;android.widget.EditText&#39;).send_keys(&#39;ceshi&#39;)
driver.find_element_by_class_name(&#39;android.widget.EditText&#39;).send_keys(&#39;123456&#39;)
driver.find_element_by_class_name(&#39;android.widget.Button&#39;).click()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;xpath-定位&#34;&gt;xpath 定位&lt;/h2&gt;
&lt;p&gt;xpath 定位是一种路径定位方式，主要是依赖于元素绝对路径或者相关属性来定位，但是绝对路径 xpath 执行效率比较低（特别是元素路径比较深的时候），一般使用比较少。通常使用 xpath 相对路径和属性定位。&lt;/p&gt;
&lt;p&gt;1.xpath 路径表达式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;从根节点选取。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;//&lt;/td&gt;
&lt;td&gt;从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nodename&lt;/td&gt;
&lt;td&gt;选取此节点的所有子节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;选取当前节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;选取当前节点的父节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;选取属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2.xpath 匹配符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通配符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;匹配任何元素节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@*&lt;/td&gt;
&lt;td&gt;匹配任何属性节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;node()&lt;/td&gt;
&lt;td&gt;匹配任何类型的节点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;实践案例&#34;&gt;实践案例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;driver.find_element_by_id(&#39;com.c503.module.chemicalindustrypack:id/tv_password&#39;).send_keys(&amp;quot;123456&amp;quot;) #输入密码
driver.find_element_by_xpath(&#39;//android.widget.TextView[@text=&amp;quot;主页&amp;quot;]&#39;).click() #点击主页按钮
driver.find_element_by_xpath(&amp;quot;//android.widget.ImageView&amp;quot;).click() #点击第一个图片
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;扩展资料：&lt;a href=&#34;http://www.w3school.com.cn/xpath/xpath_syntax.asp&#34;&gt;xpath 语法&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;appium-之-toast-元素识别&#34;&gt;appium 之 Toast 元素识别&lt;/h1&gt;
&lt;h3 id=&#34;问题思考&#34;&gt;问题思考&lt;/h3&gt;
&lt;p&gt;在日常使用 App 过程中，经常会看到 App 界面有一些弹窗提示（如下图所示）这些提示元素出现后等待 3 秒左右就会自动消失，那么我们该如何获取这些元素文字内容呢？&lt;/p&gt;
&lt;h2 id=&#34;toast-简介&#34;&gt;Toast 简介&lt;/h2&gt;
&lt;p&gt;Android 中的 Toast 是一种简易的消息提示框。&lt;br&gt;
当视图显示给用户，在应用程序中显示为浮动。和 Dialog 不一样的是，它永远不会获得焦点，无法被点击。&lt;/p&gt;
&lt;p&gt;Toast 类的思想就是尽可能不引人注意，同时还向用户显示信息，希望他们看到。而且 Toast 显示的时间有限，一般 3 秒左右就消失了。因此使用传统的元素定位工具，我们是无法定位到 Toast 元素的（传说中低调奢华有内涵）。&lt;/p&gt;
&lt;h2 id=&#34;appium-toast-内容获取&#34;&gt;Appium Toast 内容获取&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Add ability to verify TOAST messages (these can’t be interacted with, only text retrieval allowed)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Appium 1.6.3 开始支持识别 Toast 内容，主要是基于 UiAutomator2，因此需要在 Capablity 配置如下参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;desired_caps[&#39;automationName&#39;]=&#39;uiautomator2&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 appium-uiautomator2-driver: 安装命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install appium-uiautomator2-driver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装 selenium 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install selenium
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后使用如下命令检测是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip show selenium
Name: selenium
Version: 3.11.0
Summary: Python bindings for Selenium
Home-page: https://github.com/SeleniumHQ/selenium/
Author: UNKNOWN
Author-email: UNKNOWN
License: Apache 2.0
Location: c:\python35\lib\site-packages
Requires:
Required-by: Appium-Python-Client
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试场景&#34;&gt;测试场景&lt;/h3&gt;
&lt;p&gt;进入登录界面输入错误的用户名或者密码，获取 Toast 内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“用户名或密码错误，你还可以尝试 4 次”&lt;/li&gt;
&lt;li&gt;“验证失败次数过多，请 15 分钟后再试”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;get_toast.py&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# coding=utf-8
from find_element.capability import driver
from selenium.webdriver.support.ui import WebDriverWait

driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).clear()
driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_email_edittext&#39;).send_keys(&#39;zxss018&#39;)

driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_password_edittext&#39;).send_keys(&#39;zxw2018&#39;)
driver.find_element_by_id(&#39;com.tal.kaoyan:id/login_login_btn&#39;).click()


error_message=&amp;quot;用户名或密码错误，你还可以尝试4次&amp;quot;
limit_message=&amp;quot;验证失败次数过多，请15分钟后再试&amp;quot;

message=&#39;//*[@text=\&#39;{}\&#39;]&#39;.format(error_message)
# message=&#39;//*[@text=\&#39;{}\&#39;]&#39;.format(limit_message)

toast_element=WebDriverWait(driver,5).until(lambda x:x.find_element_by_xpath(message))
print(toast_element.text)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意toast-内容为中文时顶部必须注释-codingutf-8-否则会因为编解码导致文字识别失败&#34;&gt;&lt;strong&gt;注意：Toast 内容为中文时，顶部必须注释# coding=utf-8 否则会因为编解码导致文字识别失败。&lt;/strong&gt;&lt;/h3&gt;
">Appium自动化测试简单入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/4tSEylPV0/"" data-c="
          &lt;p&gt;dockers仓库Harbor是常用的企业级私有镜像仓库&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83&#34;&gt;部署环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E5%8F%8Adocker-compose%E5%AE%89%E8%A3%85&#34;&gt;Docker及Docker-compose安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#harbor%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE&#34;&gt;Harbor部署配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8&#34;&gt;Docker客户端使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#harbor%E7%9A%84%E7%99%BB%E9%99%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B&#34;&gt;harbor的登陆和使用基本操作如下：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#harbor%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86&#34;&gt;Harbor服务管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;部署环境&#34;&gt;部署环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Centos7.3 x64&lt;/li&gt;
&lt;li&gt;docker-ce-17.06.0&lt;/li&gt;
&lt;li&gt;docker-compose-1.15.0&lt;/li&gt;
&lt;li&gt;Python-2.7.5(系统默认)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker及docker-compose安装&#34;&gt;Docker及Docker-compose安装&lt;/h2&gt;
&lt;p&gt;运行下面的脚本安装docker和docker-compose&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -O myshell.sh https://fs.tn/myshell.sh &amp;amp;&amp;amp; bash myshell.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;harbor部署配置&#34;&gt;Harbor部署配置&lt;/h2&gt;
&lt;p&gt;下载harbor的离线安装包，目前最新版本为1.7.4.如果需要安装别的版本，可以自行到github上下载其他版本的离线安装包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget https://storage.googleapis.com/harbor-releases/release-1.7.0/harbor-offline-installer-v1.7.4.tgz
tar xf harbor-offline-installer-v1.7.4.tgz
cd harbor/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;vim harbor.cfg&lt;/code&gt; 编辑配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hostname = harbor.com #设置域名
ui_url_protocol = http #如果需要配置ssl 这里填写https ，推荐配置https，可以省事很多
db_password = db_password #设置数据库密码，务必修改
ssl_cert = #SSL证书的路径，仅在协议设置为https时应用。
ssl_cert_key = #SSL密钥的路径，仅在协议设置为https时应用。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的，可以参考github上的说明进行配置，比如邮件、LDAP登陆、存储库等配置。配置成功后运行下面的命令安装：&lt;br&gt;
&lt;code&gt;./install.sh&lt;/code&gt;&lt;br&gt;
安装成功后，可以通过http://harbor.com/ 访问。 默认管理员用户名/密码为admin / Harbor12345&lt;/p&gt;
&lt;h3 id=&#34;docker客户端使用&#34;&gt;Docker客户端使用&lt;/h3&gt;
&lt;p&gt;如果Harbor默认使用的http协议,就需要在Docker client上的Dockerd服务增加–insecure-registry hub.wow&lt;br&gt;
Centos7修改方式为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vi /lib/systemd/system/docker.service
#在ExecStart=/usr/bin/dockerd后面加上--insecure-registry harbor.com
ExecStart=/usr/bin/dockerd --insecure-registry harbor.com
#保存退出后，重启docker服务
systemctl daemon-reload
systemctl reload docker
service docker restart
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;harbor的登陆和使用基本操作如下&#34;&gt;harbor的登陆和使用基本操作如下：&lt;/h3&gt;
&lt;p&gt;登陆到harbor&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker login -u admin -p Harbor12345 harbor.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本地基于mysql:latest创建tag。（需要先docker pull mysql:latest拉去官方镜像）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker tag mysql:latest harbor.com/admin/mysql:latest&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;推送本地镜像mysql:latest 到hub.wow私有仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt; docker push harbor.com/admin/mysql:latest&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;拉取刚才上传的镜像&lt;/p&gt;
&lt;p&gt;&lt;code&gt; docker pull harbor.com/admin/mysql:latest&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;harbor服务管理&#34;&gt;Harbor服务管理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cd harbor/
docker-compose -f ./docker-compose.yml [ up|down|ps|stop|start ]
&lt;/code&gt;&lt;/pre&gt;
">企业级Docker私有仓库之Harbor部署</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/nYF6x-WNr/"" data-c="
          &lt;h1 id=&#34;风险识别清单&#34;&gt;风险识别清单&lt;/h1&gt;
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt; 分类 &lt;/td&gt;
    &lt;td&gt; 清单 &lt;/td&gt;
    &lt;td&gt; 说明 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;2&#34;&gt; 需求 &lt;br/&gt;
    &lt;td&gt;产品片的业务需求、用户需求、功能需求和系统需求是否完整、清晰&lt;/td&gt;
    &lt;td&gt; 检查需求的质量，确保需求能够有效知道开发和测试 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员在进行产品设计之前是否充分理解了产品的需求&lt;/td&gt;
    &lt;td&gt;在项目种非常容易出现开发人员并没有完全理解产品的需求，就开始设计编码，直到系统测试阶段才发现和需求不符的问题。一旦出现这样的问题，产品很有可能就会返工，对产品来说是致命的打击。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;9&#34;&gt; 设计 &lt;br/&gt;
    &lt;td&gt;是否使用了“新技术”&lt;/td&gt;
    &lt;td&gt; 包括产品之前未使用的新构架、新平台、新算法等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;系统中是否会存在一些设计“瓶颈”？如果存在，是否有应对措施&lt;/td&gt;
    &lt;td&gt;例如，产品的老架构能否满足产品新增的特性的性能、可靠性方面的要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;产品是否设计得过于复杂，难以理解？&lt;/td&gt;
    &lt;td&gt;再项目种，难以理解的设计，问题往往也是比较多的。所以需要重点关注。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员是否能够讲清楚产品设计&lt;/td&gt;
    &lt;td&gt;一般来说，开发人员是可以讲清楚自己的设计。如果开发人员无法讲清楚自己的设计，说明设计本身就存着一些问题。这部分设计的可维护性，可移植性就可能不会太好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员对异常、非功能方面的内容是否考虑得足够全面&lt;/td&gt;
    &lt;td&gt;例如，如果数据被损坏，会发生什么？如何处理？这个功能的使用的资源或者组件有没有可能被其他功能修改或者影响。有没有考虑过最大负载，容灾，灾备。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员在设计中是否存在一些比较担心的地方？&lt;/td&gt;
    &lt;td&gt;测试人员可以适当关注开发人员的主观感受，而不仅仅是设计文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员是否会考虑和设计一些测试性或者易于定位的功能&lt;/td&gt;
    &lt;td&gt;由“不易于验证的设计”可以推测出开发人员在设计编码时的自检可能也是不充分的，这部分代码质量可能并不高，相对风险较高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;对于一个需要多人（或者多组）才能配合完成的功能，是否有人会进行整体的设计，协调和把关？&lt;/td&gt;
    &lt;td&gt;当开发人员的设计会依赖于其他设计时，开发人员一般会假设接口能够满足需求，而忽视彼此的沟通和确认的环节，使得产品再集成开发时候出现问题，影响产品质量和项目进度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;对有依赖或约束的内容，是否有充分的考虑&lt;/td&gt;
    &lt;td&gt;例如，与产品配套的日志、审计类产品是否能够满足产品的发布周期？与产品相关的平台是否稳定？&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;4&#34;&gt; 流程 &lt;br/&gt;
    &lt;td&gt;项目是否使用了新的流程，开发方法等&lt;/td&gt;
    &lt;td&gt; 例如，从传统瀑布开发模式到开始使用敏捷开发的模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员是否会进行自测？是如何进行自测的？测试的深度和发现问题的情况如何&lt;/td&gt;
    &lt;td&gt;开发自测是产品代码质量的重要保证活动。测试需要关注开发人员的自测方法和发现问题的清空。一般来说，自测充分的模块，代码质量可能会相对较好，反之就可能会比较差。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员如何进行代码修改，是如何保证修改的正确性&lt;/td&gt;
    &lt;td&gt;例如，开发人员是否会对修改方案进行评审？是否会对修改的代码进行检视和评估？是否会对修改进行测试验证？是否会进行回归测试等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;开发人员是如何进行版本管理的？&lt;/td&gt;
    &lt;td&gt;例如，开发人员是否存在版本分支管理混乱的问题？是否会随意修改、合入代码，而不对变动做记录和控制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;2&#34;&gt; 变更 &lt;br/&gt;
    &lt;td&gt;新版本在旧功能方面做了哪些修改？修改后的主要影响是什么？&lt;/td&gt;
    &lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;在项目过程中，需求是否总是在变更？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;6&#34;&gt; 组织和人 &lt;br/&gt;
    &lt;td&gt;那些模块是由其他组织开发的？他们在哪里开发？开发流程、能力如何？&lt;/td&gt;
    &lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;产品的研发团队（包括需求、开发和测试）是否存在于不同的地方？彼此分工如何？沟通是否顺畅？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;团队人员能力如何？经验如何（包括需求、开发和测试团队）？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;团队是否稳定（包括需求、开发和测试团队）？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;团队的人手是否充足（包括需求、开发和测试团队）？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;测试环境是否具备（包括必备的工具、硬件设备）？&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td rowspan=&#34;3&#34;&gt; 历史 &lt;br/&gt;
    &lt;td&gt;哪些特性在产品测试时就存在很多bug？
    &lt;/td&gt;
    &lt;td&gt; 根据“bug聚集性”的力量，历史上的bug重灾区，当前版本可能继续需要重点关注 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;哪些特性存在较多的客户反馈问题？&lt;/td&gt;
    &lt;td&gt;客户反馈的问题比较多，说明之前可能存在一些测试不充分的地方，在当前版本需要重点关注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;历史上哪些情况曾经导致过阻塞测试活动的问题？&lt;/td&gt;
    &lt;td&gt;需要对这些问题进行根因分析和总结，防止同意的问题在新的项目中再度发生，历史悲剧再度重演&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
">项目风险识别清单</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/nZC1pNLO0/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%BA%A7%E7%B4%A7%E6%80%A5&#34;&gt;一级（紧急）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E7%BA%A7-%E4%B8%A5%E9%87%8D&#34;&gt;二级 (严重）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E7%BA%A7%E6%99%AE%E9%80%9A&#34;&gt;三级（普通）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E7%BA%A7%E8%BD%BB%E5%BE%AE&#34;&gt;四级（轻微)&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%B9%E5%81%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86&#34;&gt;对偶发问题的处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;一级紧急&#34;&gt;一级（紧急）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导致操作系统死机、重启、自动关闭、内存泄漏等缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导致操作系统无响应、服务未启动（或启动后关闭）等缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用模块无法启动或异常退出、停止工作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导致用户数据丢失、损 坏或严重的数值计算错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何导致应用无法提供服务或需要重启才能继续使用的情况；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能设计与需求严重不符（需要以总体提供的功能设计说明为依据进行判定）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他导致无法继续测试的缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统存在严重的安全漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;二级-严重&#34;&gt;二级 (严重）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本业务功能未实现（需要以总体提供的功能设计说明为依据进行判定）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能错误，或功能不能持续正常实现等问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据存储或展示错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轻微的数值计算错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用所提供的功能或服务受到影响的错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用造成操作系统响应缓慢（需要以总体提供的系统性能指标为依据进行判定）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用内流程和分支无法执行，影响用户使用的缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效性、可靠性等问题：例如缺少验证，导致系统出错或无法执行流程的问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品存在严重的兼容性问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署文档错误，导致无法成功部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;三级普通&#34;&gt;三级（普通）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不影响功能实现的其他缺陷，主要为系统易用性方面；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未优化的性能缺陷，例如应用系统内响应较慢，或在数据较多时响应慢；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作界面错误，例如界面元素、光标跳转或定位、指示性语句错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要有提示的地方没有提示，或者提示不能引导用户正确操作的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;四级轻微&#34;&gt;四级（轻微)&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对应用有一定影响但是触发条件极端，不在用户一般操作范围内的缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轻微、提示类缺陷，展示顺序、、错字、字体和 UI 等不影响使用的缺陷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户使用不便或易出现操作错误；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户难以理解的功能或操作步骤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建议类：界面设计、描述更改、流程优化等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;对偶发问题的处理&#34;&gt;对偶发问题的处理&lt;/h3&gt;
&lt;p&gt;在测试中偶然出现的问题，都需要进行记录跟踪，如果在测试过程中无法再次触发，或者触发几率很低（小于 1/1000）则此问题记录为四级 BUG（下个版本需要继续验证），如果测试过程中频繁出现，触发几率较高（大于 1/1000）的缺陷记为三级bug（需要跟踪的问题）。&lt;/p&gt;
&lt;p&gt;对于未复现的缺陷，测试人员不应随意关闭。应该多次复现尝试之后，且和研发、产品经理共同确认过后予以关闭。&lt;/p&gt;
">缺陷等级定义</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/u5nXk2JTl/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bug-%E6%A0%87%E9%A2%98&#34;&gt;Bug 标题：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4&#34;&gt;重现步骤：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83&#34;&gt;测试环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90&#34;&gt;具体例子&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B-1-%E5%87%BA%E7%8E%B0%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98%E9%9C%80%E8%A6%81%E6%A0%87%E6%B3%A8%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0&#34;&gt;例 1、出现概率问题需要标注出现次数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B-2-%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%90%8C%E4%B8%80%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1%E5%88%86%E5%B0%8F%E7%82%B9%E8%BF%9B%E8%A1%8C%E4%B9%A6%E5%86%99&#34;&gt;例 2、不同操作导致的同一问题现象，分小点进行书写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B-3-%E5%90%8C%E4%B8%80%E9%97%AE%E9%A2%98%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E9%83%BD%E5%AD%98%E5%9C%A8%E6%97%B6%E9%87%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4%E7%BB%93%E6%9E%9C%E4%B8%AD%E8%A6%81%E5%A4%87%E6%B3%A8%E6%A0%87%E6%98%8E-xxx-%E6%A8%A1%E5%9D%97%E4%B9%9F%E5%AD%98%E5%9C%A8%E6%AD%A4%E9%97%AE%E9%A2%98&#34;&gt;例 3、同一问题不同模块都存在时，【重现步骤】[结果]中要备注标明 XXX 模块也存在此问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96%E8%A6%81%E6%B1%82&#34;&gt;其他要求：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;bug-标题&#34;&gt;Bug 标题：&lt;/h2&gt;
&lt;p&gt;【[测试系统]-[功能点]-[页面]】问题描述例如：&lt;br&gt;
【android-通讯录】从业人员信息姓名较长与勾选按钮重叠；&lt;br&gt;
【iOS-WIFI 采集-设备管理】新建设备输入设备经度 100-109 不能保存成功&lt;/p&gt;
&lt;h2 id=&#34;重现步骤&#34;&gt;重现步骤：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[步骤]
前置条件：有就写明，无就不写
1、模块/页面+具体操作
2、模块/页面+具体操作

[结果]

[期望]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;APP测试写明：手机型号 + 系统版本
例如：华为honor GHE-TL00 + Android 5.0.2
WEB端测试写明：系统版本 + 浏览器版本 + 系统分辨率
例如：win7 + 火狐50.1.0 + 分辨率1440*900
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;由于特殊数据引起的 BUG，【重现步骤】[步骤]中要注明测试使用数据例如：测试使用数据：XXXXX&lt;/li&gt;
&lt;li&gt;概率性问题【BUG 标题】要写明概率性/高概率/低概率出现 XXX 问题；【重现步骤】[结果]中要注明测试次数和出现问题次数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;具体例子&#34;&gt;具体例子&lt;/h2&gt;
&lt;h3 id=&#34;例-1-出现概率问题需要标注出现次数&#34;&gt;例 1、出现概率问题需要标注出现次数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;BUG标题：
【android1.0-登录】概率性出现账号异地登录后原账号所在设备APP程序异常退出

重现步骤：
[步骤]
1、账号A在设备B1上登录APP
2、账号A在设备B2上登录APP
[结果]
概率性出现账号异地登录后原账号所在设备APP程序异常退出（测试30次，出现2次）
[期望]
正常显示异地登录提示
[测试环境]
华为honor GHE-TL00 + Android 5.0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例-2-不同操作导致的同一问题现象分小点进行书写&#34;&gt;例 2、不同操作导致的同一问题现象，分小点进行书写&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;BUG标题：
【iOS1.2-其他】APP程序异常退出

重现步骤：
[步骤]
1.	我的视频界面查看设备，在设备显示断开连接的时候点击设备，出现闪退
2.	打开APP，出现闪退，具体操作如下：
①APP登陆后，返回桌面静置手机
②锁屏后，唤起屏幕，点击桌面APP图标
③APP进入登录页面后，闪退，返回桌面
④再次点击APP 正常进入登录页面
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例-3-同一问题不同模块都存在时重现步骤结果中要备注标明-xxx-模块也存在此问题&#34;&gt;例 3、同一问题不同模块都存在时，【重现步骤】[结果]中要备注标明 XXX 模块也存在此问题&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;BUG 标题：
【android1.0-WIFI 采集-信息查询】查询过程中页面出现-暂无信息-提示
重现步骤：

[步骤]
进入【WIFI 采集】-【信息查询】页面，输入查询条件，进行查询

[结果]
查询过程中页面出现-暂无信息-提示
PS：【黑名单布防管理】页面查询、删除操作时也存在同样的现象
【设备管理】页面删除操作时也存在同样的现象

[期望]
查询过程中页面正常加载

[测试环境]
win7 + 火狐 50.1.0 + 分辨率 1440\*900
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;其他要求&#34;&gt;其他要求：&lt;/h2&gt;
&lt;p&gt;① 注意文字缩进&lt;br&gt;
② BUG 截图适当添加文字说明&lt;/p&gt;
">BUG编写规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/vwJHMiAcj/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA%E5%B9%B6%E6%A0%A1%E5%AF%B9%E6%97%B6%E9%97%B4&#34;&gt;修改时区并校对时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#firewall-%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4&#34;&gt;firewall 防火墙命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D&#34;&gt;docker 命令简单介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-compose-%E5%91%BD%E4%BB%A4&#34;&gt;docker-compose 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5&#34;&gt;git 命令速查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx-%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D&#34;&gt;NGINX 命令简单介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#screen-%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D&#34;&gt;screen 命令介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9-selinux-%E6%A8%A1%E5%9D%97&#34;&gt;修改 SELinux 模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#java-%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4&#34;&gt;java 项目相关命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pm2%E8%BF%90%E8%A1%8Cjar%E5%8C%85&#34;&gt;pm2运行jar包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
服务器一键测试脚本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget -qO- bench.sh | bash&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;修改时区并校对时间&#34;&gt;修改时区并校对时间&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
yum -y install ntpdate
ntpdate -u ntp.api.bz
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;firewall-防火墙命令&#34;&gt;firewall 防火墙命令&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;firewall-cmd --reload #重启
systemctl stop firewalld.service #停止防火墙
systemctl disable firewalld.service #开机不启动防火墙
firewall-cmd --state #查看默认防火墙状态（关闭后显示not running，开启后显示running）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-命令简单介绍&#34;&gt;docker 命令简单介绍&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker ps #查看启动的容器
docker start xxx #启动容器，XXX为容器ID或容器名
docker stop xxx #停止容器，XXX为容器ID或容器名
docker rm xxx #删除容器，XXX为容器ID或容器名
docker images #查看镜像
docker rmi xxx #删除镜像，XXX为镜像ID或镜像名
docker system prune -a #清理所有不用的数据(停止的容器,不使用的volume,不使用的networks,悬挂的镜像)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker更换为国内源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#编辑daemon.json文件
vi /etc/docker/daemon.json
#加入源的连接
{
&amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://docker.mirrors.ustc.edu.cn&amp;quot;]
}
#保存退出
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-compose-命令&#34;&gt;docker-compose 命令&lt;/h3&gt;
&lt;p&gt;以下命令中加入-f参数可以指定docker-compose.yml文件，否则执行下面命令时，当前目录中必须要要有docker-compose文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#后台启动docker-compose
docker-compose up -d
#关闭docker-compose
docker-compose down
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;git-命令速查&#34;&gt;git 命令速查&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://i.loli.net/2019/02/20/5c6cc61154374.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;nginx-命令简单介绍&#34;&gt;NGINX 命令简单介绍&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#检查nginx配置文件是否有错误（也可以查看nginx配置文件位置）
nginx -t
#重新加载nginx配置文件（不需要重新启动nginx）
nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;screen-命令介绍&#34;&gt;screen 命令介绍&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#新建一个叫xxx的终端
screen -S xxx
#回到xxx终端
screen -dr xxx
#显示screen的列表
screen -ls
#screen回到上一个终端
ctrl+a然后按d
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改-selinux-模块&#34;&gt;修改 SELinux 模块&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#查看SELinux当前状态：
getenforce

#修改SELinux状态（临时修改,重启机器后失效)
 setenforce 0  #将SELinux修改为Permissive状态(遇到违反安全策略的,会采取警告,允许通过)
 setenforce 1  #将SELinux状态修改为Enforcing状态(遇到违反安全策略的,不允许通过)

#修改SELinuxw为禁用状态 (永久性,重启机器后保持生效)
-打开文件: /etc/selinux/config 修改 SELINUX = disabled
-重启机器后生效，重启机器命令:reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java-项目相关命令&#34;&gt;java 项目相关命令&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#后台运行jar包（不推荐使用，建议使用pm2）
nohup java -jar XXX.jar &amp;amp;
#打包项目并跳过单元测试（首次打包会下载依赖所以比较久）
./mvnw clean package -Dmaven.test.skip=true
或者
mvn clean package -Dmaven.test.skip=true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pm2运行jar包&#34;&gt;pm2运行jar包&lt;/h3&gt;
&lt;p&gt;在源码目录创建一个pm2.config.js文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = {
    apps: [
	{
            name: &#39;xxxxx-server&#39;, #服务的名字
            script: &#39;java&#39;,
            args: [
                &#39;-jar&#39;,
                &#39;target/xxxxx-0.0.1.jar&#39;, #jar包的位置
                &#39;--spring.profiles.active=prod&#39; #额外命令可以根据实际进行增删
            ],
            cwd: &#39;.&#39;,
            interpreter: &#39;&#39;
        }
    ]
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上为基础示例，如果需要加其他命令，需要按照格式在args里面进行修改。然后运行pm2 start pm2.config.js&lt;/p&gt;
&lt;p&gt;如果要便捷的一次性包含打包和运行pm2，可以新建一个run.sh文件，写入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh
cd `dirname $0`
./mvnw clean package -Dmaven.test.skip=true &amp;amp;&amp;amp; pm2 restart pm2.config.js
&lt;/code&gt;&lt;/pre&gt;
">Linux基础命令记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/I4uADoACK/"" data-c="
          &lt;h3 id=&#34;nginx配置文件注释&#34;&gt;nginx配置文件注释&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;user root; #设置nginx权限用户
worker_processes  auto; #工作进程：数目。根据硬件调整，通常等于CPU数量或者2倍于CPU。

events {
    worker_connections  32768; #没个工作进程的最大连接数量。根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行
    multi_accept on; #告诉nginx收到一个新连接通知后接受尽可能多的连接。
}

proxy_cache_path /nginx1.13.2/temp/cache_temp levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=40g; #设置内存缓存空间大小为500MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为40GB。

gzip  on; #开启gzip压缩
gzip_comp_level 3; #压缩质量等级，越大压缩的效果越好，但是cpu消耗越高，通常为3即可
gzip_proxied any; #允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求，开启反向代理后需要设置。
gzip_min_length 1k; #设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。
gzip_types text/plain application/x-javascript application/javascript text/javascript text/css application/xml application/x-httpd-php image/jpeg image/gif image/png;  #设置需要压缩的数据格式，以上为压缩图片格式、css、js和文本
gzip_buffers 32 4k;  #设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。
gzip_disable &amp;quot;MSIE[1-6]\.&amp;quot;;  #设置IE 1-6版本不压缩
gzip_vary on;  #根据客户端的HTTP头来判断，是否需要压缩

upstream gfmh {             # 负载均衡服务器设置，设置名字为gfmh
    ip_hash;  # 基于IPhash的模式访问 如果不设置，默认为轮询模式
    server 192.168.1.46:8080 ; #分别对应三台web服务器
    server 192.168.1.134:8080 ; 
    server 192.168.1.134:8080 ; 
}  

#负载均衡server的配置
server {
        listen       8888;  #设置监听的端口 生产环境应该为80或者443
        server_name  192.1
    location /phymcms   #反向代理目录
    {
        proxy_pass http://gfmh;  #反向代理到负载均衡上
        index index.html index.htm; #默认web文件
        proxy_set_header Host $host:$server_port;  #传递IP和端口
        proxy_set_header X-Real-IP $remote_addr; #传递真实IP地址
        proxy_set_header X-Real-port $remote_port; #传递真实端口
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_set_header REMOTE-HOST $remote_addr; #设置http头的地址
        
        #缓存相关配置
        proxy_cache cache_one;  #设置缓存的目录cache_one
        proxy_cache_key $host$request_uri$is_args$args;#设置缓存的key
        proxy_cache_valid 200 304 301 302 1h;  #设置缓存时间
        
        #持久化连接相关配置
        proxy_connect_timeout 30s; #设置连接超时时间
        proxy_read_timeout 86400s; #设置超时时间
        proxy_send_timeout 30s; #设置超时时间
        proxy_http_version 1.1; #设置http版本
        proxy_set_header Upgrade $http_upgrade; #设置刷新
        proxy_set_header Connection &amp;quot;upgrade&amp;quot;; #设置http刷新头
        add_header X-Cache $upstream_cache_status; #设置负载均衡缓存状态头
        expires 12h; 
    }

#反向代理的server配置说明
server {
    listen	 8081;
    server_name  192.168.1.217;

    proxy_set_header           Host $host;
    proxy_set_header           X-Real-IP $remote_addr;
    proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
    add_header Access-Control-Allow-Origin *;

    location /server-status #开启nginx状态监控
    {
        stub_status on;
        access_log  /var/log/nginx/status.access.log;
    }

    location ^~ /app-api-server/ #反向代理到API服务器
    {
        proxy_pass  http://192.168.1.154:8765/app-api-server/;
    }

    location / #反向代理到本地80端口
    {
        proxy_pass http://127.0.0.1:80;
    }
&lt;/code&gt;&lt;/pre&gt;
">NGINX配置文件详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/YESFQ3hzt/"" data-c="
          &lt;p&gt;jmx监控程序在jdk目录bin下面的jvisualvm&lt;/p&gt;
&lt;p&gt;tomcat开启jmx监控，windows在bin/catalina.bat（linux下为catalina.sh)&lt;br&gt;
在-- Execute The Requested Command -----的前面加入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set JMX_REMOTE_CONFIG=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8999-Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false  
set CATALINA_OPTS=%CATALINA_OPTS% %JMX_REMOTE_CONFIG% 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置完成后，运行tomcat程序&lt;/p&gt;
&lt;p&gt;打开jvisualvm然后连接tomcat所在的服务器，输入ip:端口就可以监控到对应tomcat&lt;/p&gt;
&lt;p&gt;如果需要监控同一台电脑不同的tomcat，可以设置不同的监控端口，将上面的代码中的8999修改为其他的不冲突端口即可&lt;/p&gt;
&lt;p&gt;如果要使用zabbix监控的话，直接再主机中添加对应的地址和端口即可&lt;/p&gt;
">开启jmx监控tomcat各项性能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/vNMK87vBM/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#zabbix%E7%9B%91%E6%8E%A7%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8Bwindows%E5%92%8Clinux&#34;&gt;zabbix监控端部署教程（Windows和Linux）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#windows%E9%83%A8%E7%BD%B2agent&#34;&gt;windows部署agent&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E9%98%B2%E7%81%AB%E5%A2%99%E9%9C%80%E8%A6%81%E5%BC%80%E6%94%BE10050%E7%AB%AF%E5%8F%A3&#34;&gt;系统防火墙需要开放10050端口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux%E4%B8%8B%E9%83%A8%E7%BD%B2agent&#34;&gt;linux下部署agent&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#centos6%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%83%A8%E7%BD%B2agent&#34;&gt;centos6系统下部署agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#centos7%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%83%A8%E7%BD%B2agent&#34;&gt;centos7系统下部署agent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;zabbix监控端部署教程windows和linux&#34;&gt;zabbix监控端部署教程（Windows和Linux）&lt;/h1&gt;
&lt;h2 id=&#34;windows部署agent&#34;&gt;windows部署agent&lt;/h2&gt;
&lt;p&gt;官网下载agent后解压，找到conf下的配置文件 zabbix_agentd.win.conf ，修改LogFile、Server、ServerActive 、Hostname这几个参数&lt;/p&gt;
&lt;p&gt;Server: zabbix server的ip地址，&lt;/p&gt;
&lt;p&gt;ServerActive: zabbix 主动监控server的ip地址，&lt;/p&gt;
&lt;p&gt;其中Server和ServerActive都指定zabbix Server的IP地址，不同的是，前者是被动后者是主动。也就是说Server这个配置是用来允许172.17.22.155这个ip来我这取数据。而ServerActive的172.17.22.155的意思是，客户端主动提交数据给他。&lt;/p&gt;
&lt;p&gt;Hostname 主机名，必须唯一，区分大小写。Hostname必须和zabbix web上配置的一直，否则zabbix主动监控无法正常工作。因为agent拿着这个主机名去问server，我有配置主动监控项吗？server拿着这个主机名去配置里面查询，然后返回信息。&lt;/p&gt;
&lt;p&gt;zabbix agent检测分为主动（agent active）和被动（agent）两种形式，主动与被动的说法均是相对于agent来讨论的。&lt;/p&gt;
&lt;p&gt;主动：agent请求server获取主动的监控项列表，并主动将监控项内需要检测的数据提交给server/proxy&lt;/p&gt;
&lt;p&gt;被动：server向agent请求获取监控项的数据，agent返回数据。&lt;/p&gt;
&lt;p&gt;修改好配置文件后，用CMD（需有管理员权限）将Zabbix Agent安装为Windows系统的服务，在windows控制台下执行以下命令（文件地址需要自行修改）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\\zabbix\\bin\\win64\\zabbix\_agentd.exe -i -c C:\\zabbix\\conf\\zabbix\_agentd.win.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;控制台输出信息如下，表示安装成功：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zabbix\_agentd.exe [4864]: service [Zabbix Agent] installed successfully zabbix\_agentd.exe [4864]: event source [Zabbix Agent] installed successfully&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动zabbix-agent客户端&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\\zabbix\\bin\\win64\\zabbix\_agentd.exe -c C:\\zabbix\\conf\\zabbix\_agentd.win.conf -s&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;系统防火墙需要开放10050端口&#34;&gt;系统防火墙需要开放10050端口&lt;/h3&gt;
&lt;p&gt;此外Windows系统建议自行配置网卡监控信息，linux可以使用自动发现&lt;/p&gt;
&lt;h1 id=&#34;linux下部署agent&#34;&gt;linux下部署agent&lt;/h1&gt;
&lt;p&gt;Linux系统分为centos6.x和7.x&lt;/p&gt;
&lt;h2 id=&#34;centos6系统下部署agent&#34;&gt;centos6系统下部署agent&lt;/h2&gt;
&lt;p&gt;先添加源&lt;code&gt;rpm -i http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/6/x86_64/zabbix-release-3.4-1.el6.noarch.rpm&lt;/code&gt;&lt;a href=&#34;http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/6/x86_64/zabbix-release-3.4-1.el6.noarch.rpm&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然运行&lt;code&gt;yum -y install zabbix-agent&lt;/code&gt;&lt;br&gt;
安装完成后配置文件在&lt;code&gt;/etc/zabbix/zabbix_agentd.conf&lt;/code&gt;和Windows一样，修改里面的hostname和server以及ServerActive&lt;br&gt;
配置完成后运行&lt;code&gt;service zabbix-agent start&lt;/code&gt;&lt;br&gt;
重启为&lt;code&gt;service zabbix-agent restart&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;centos7系统下部署agent&#34;&gt;centos7系统下部署agent&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;先添加源&lt;code&gt;rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm&lt;/code&gt;&lt;a href=&#34;http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://mirrors.aliyun.com/zabbix/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然运行&lt;code&gt;yum -y install zabbix-agent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;安装完成后配置文件在`/etc/zabbix/zabbix_agentd.conf`和Windows一样，修改里面的hostname和server以及ServerActive

配置完成后运行`systemctl start zabbix-agent`

重启为`systemctl restart zabbix-agent`
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
">zabbix监控端部署教程（Windows和Linux）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/5fDjh_lix/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E9%83%A8%E7%BD%B2zabbix%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AB%AF&#34;&gt;docker部署zabbix监控系统服务端&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B&#34;&gt;启动一个空的MySQL服务器实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8zabbix-java-gateway%E5%AE%9E%E4%BE%8B&#34;&gt;启动Zabbix Java gateway实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8zabbix-web-%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%B0%86%E5%AE%83%E4%B8%8Emysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%92%8Czabbix-server%E5%AE%9E%E4%BE%8B%E5%85%B3%E8%81%94&#34;&gt;启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker%E9%83%A8%E7%BD%B2agent&#34;&gt;docker部署agent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;docker部署zabbix监控系统服务端&#34;&gt;docker部署zabbix监控系统服务端&lt;/h1&gt;
&lt;h3 id=&#34;启动一个空的mysql服务器实例&#34;&gt;启动一个空的MySQL服务器实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --name mysql-server -t \
-e MYSQL_DATABASE=&amp;quot;zabbix&amp;quot; \
-e MYSQL_USER=&amp;quot;zabbix&amp;quot; \
-e MYSQL_PASSWORD=&amp;quot;zabbix_zjhthxjk&amp;quot; \
-e MYSQL_ROOT_PASSWORD=&amp;quot;root_abc.123654&amp;quot; \
-d mysql:5.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;启动zabbix-java-gateway实例&#34;&gt;启动Zabbix Java gateway实例&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --name zabbix-java-gateway -t \
-d zabbix/zabbix-java-gateway:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name zabbix-server-mysql -t \
-e DB_SERVER_HOST=&amp;quot;mysql-server&amp;quot; \
-e MYSQL_DATABASE=&amp;quot;zabbix&amp;quot; \
-e MYSQL_USER=&amp;quot;zabbix&amp;quot; \
-e MYSQL_PASSWORD=&amp;quot;zabbix_zjhthxjk&amp;quot; \
-e MYSQL_ROOT_PASSWORD=&amp;quot;root_abc.123654&amp;quot; \
-e ZBX_JAVAGATEWAY=&amp;quot;zabbix-java-gateway&amp;quot; \
-e ZBX_JAVAGATEWAY_ENABLE=&amp;quot;true&amp;quot; \
--link mysql-server:mysql \
--link zabbix-java-gateway:zabbix-java-gateway \
-p 10051:10051 \
-d zabbix/zabbix-server-mysql:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在部署后可以将宿主机的时区文件复制到docker里面，命令如下&lt;br&gt;
&lt;code&gt;docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID:/etc/localtime&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;启动zabbix-web-接口并将它与mysql服务器实例和zabbix-server实例关联&#34;&gt;启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --name zabbix-web-nginx-mysql -t \
-e DB_SERVER_HOST=&amp;quot;mysql-server&amp;quot; \
-e MYSQL_DATABASE=&amp;quot;zabbix&amp;quot; \
-e MYSQL_USER=&amp;quot;zabbix&amp;quot; \
-e MYSQL_PASSWORD=&amp;quot;zabbix_zjhthxjk&amp;quot; \
-e MYSQL_ROOT_PASSWORD=&amp;quot;root_abc.123654&amp;quot; \
-e PHP_TZ=&amp;quot;Asia/Shanghai&amp;quot; \
--link mysql-server:mysql \
--link zabbix-server-mysql:zabbix-server \
-p 80:80 \
-d zabbix/zabbix-web-nginx-mysql:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在部署后可以将宿主机的时区文件复制到docker里面，命令如下&lt;br&gt;
&lt;code&gt;docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID:/etc/localtime&lt;/code&gt;&lt;br&gt;
部署完web接口后需要将中文字体拷贝到容器中，命令如下：&lt;br&gt;
&lt;code&gt;docker cp hanzi.ttf 容器ID:/usr/share/zabbix/fonts&lt;/code&gt;&lt;br&gt;
然后进入web接口容器&lt;br&gt;
&lt;code&gt;docker exec -it 容器ID /bin/sh&lt;/code&gt;&lt;br&gt;
编辑配置文件中的ZBX_FONT_NAME为上面的ttf文件名hanzi&lt;br&gt;
&lt;code&gt;vi include/define.inc.php&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker部署agent&#34;&gt;docker部署agent&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run --name zabbix-agent -t \
-e ZBX_HOSTNAME=&amp;quot;HOSTNAME&amp;quot; \
-e ZBX_SERVER_HOST=&amp;quot;server ip&amp;quot; \
-p 10050:10050 \
-d zabbix/zabbix-agent:latest
&lt;/code&gt;&lt;/pre&gt;
">docker部署zabbix监控系统服务端</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/SQsxz7MCp/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%A5%E4%B8%8B%E5%9D%87%E4%B8%BA-centos7-%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E7%9A%84%E5%91%BD%E4%BB%A4%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F-yum-%E5%91%BD%E4%BB%A4%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8&#34;&gt;以下均为 centos7 环境下的安装的命令，其他系统 yum 命令无法使用。&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker-%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2%E7%9A%84%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%89%E8%A3%85-docker&#34;&gt;docker 方式部署的需要先安装 docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#centos7-%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E6%BA%90&#34;&gt;centos7 系统修改为国内阿里源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%E7%9A%84%E5%AE%89%E8%A3%85&#34;&gt;git 的安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-%E5%AE%89%E8%A3%85&#34;&gt;docker 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85-docker-compose122-%E7%89%88%E6%9C%AC&#34;&gt;安装 docker compose(1.22 版本)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx-%E5%AE%89%E8%A3%85yum&#34;&gt;nginx 安装(yum)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mysql-%E5%AE%89%E8%A3%85&#34;&gt;mysql 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#redis-%E5%AE%89%E8%A3%85&#34;&gt;redis 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nodejs-%E5%AE%89%E8%A3%85&#34;&gt;node.js 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pm2-%E5%AE%89%E8%A3%85&#34;&gt;pm2 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#yarn-%E5%AE%89%E8%A3%85&#34;&gt;yarn 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#java-%E5%AE%89%E8%A3%85&#34;&gt;java 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rabbitmq-%E5%AE%89%E8%A3%85docker&#34;&gt;rabbitmq 安装（docker）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb-%E5%AE%89%E8%A3%85docker&#34;&gt;mongoDB 安装(docker)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#activemq-%E5%AE%89%E8%A3%85docker&#34;&gt;activemq 安装(docker)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#postgres-%E5%AE%89%E8%A3%85docker&#34;&gt;postgres 安装(docker)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#erlang-%E5%AE%89%E8%A3%85&#34;&gt;erlang 安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;以下均为-centos7-环境下的安装的命令其他系统-yum-命令无法使用&#34;&gt;以下均为 centos7 环境下的安装的命令，其他系统 yum 命令无法使用。&lt;/h2&gt;
&lt;h4 id=&#34;docker-方式部署的需要先安装-docker&#34;&gt;docker 方式部署的需要先安装 docker&lt;/h4&gt;
&lt;p&gt;建议在拿到虚拟机之后，可以运行下面的脚本一键安装如 git、docker 等基础组件且会自动校对时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum -y install wget &amp;amp;&amp;amp; wget -O myshell.sh https://fs.tn/myshell.sh &amp;amp;&amp;amp; bash myshell.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;centos7-系统修改为国内阿里源&#34;&gt;centos7 系统修改为国内阿里源&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#yum源
sudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
#epel源
sudo wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo
#清理并生成新的源缓存
sudo yum clean all
sudo yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;git-的安装&#34;&gt;git 的安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install git
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;docker-安装&#34;&gt;docker 安装&lt;/h3&gt;
&lt;p&gt;yum 的方式安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# step 1: 安装必要的一些系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# Step 2: 添加软件源信息
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# Step 3: 更新并安装 Docker-CE
sudo yum makecache fast
sudo yum -y install docker-ce
# Step 4: 开启Docker服务
sudo service docker start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 docker 源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://fszmo1nj.mirror.aliyuncs.com&amp;quot;]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装-docker-compose122-版本&#34;&gt;安装 docker compose(1.22 版本)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#下载安装
sudo curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
#赋予执行权限
sudo chmod +x /usr/local/bin/docker-compose
#检查是否安装成功
docker-compose --version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nginx-安装yum&#34;&gt;nginx 安装(yum)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#安装
yum install -y nginx
# 启动，开机启动
systemctl start nginx
systemctl enable nginx
#nginx配置文件地址
/etc/nginx/nginx.conf
/etc/nginx/conf/xxx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysql-安装&#34;&gt;mysql 安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#docker安装5.7版本（passwd可以自己修改,log和数据存储地址为运行命令当前目录下的date和log）
docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -d mysql:5.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;redis-安装&#34;&gt;redis 安装&lt;/h3&gt;
&lt;p&gt;yum 的方式安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#安装EPEL库
yum -y install epel-release
yum -y install redis
#配置文件位置
/etc/redis/redis.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker 的方式安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#启动redis实例并指定端口设置密码为admin（密码可以自行修改）
docker run --name redis -d -p 6379:6379 redis --requirepass admin
#启动redis实例并开启持久储存
docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker 的部署 redis 集群（cluster 模式，需要先安装docker-compose）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#下载docker-compose配置文件
git clone https://github.com/Grokzen/docker-redis-cluster.git
#版本号可以根据情况自行修改
docker-compose build --build-arg &amp;quot;redis_version=4.0.11&amp;quot; redis-cluster
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nodejs-安装&#34;&gt;node.js 安装&lt;/h3&gt;
&lt;p&gt;yum 安装 node6 版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#安装EPEL库
yum -y install epel-release
yum -y install nodejs
#修改npm源为国内阿里云源
npm config set registry https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 nvm 管理安装不同版本的 nodejs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#使用脚本安装nvm
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash
#复制上面运行命令后显示的最后三行，然后添加到.bash_profile文件的最后，最后输入source ~/.bash_profile
#查看远程的nodejs版本
nvm ls-remote
#安装8.11版本的nodejs
nvm install 8.11.0
#选择使用8.11
nvm use 8.11.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pm2-安装&#34;&gt;pm2 安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#先安装好nodejs后再执行下面命令
npm -g i pm2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;yarn-安装&#34;&gt;yarn 安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo
yum install -y yarn
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java-安装&#34;&gt;java 安装&lt;/h3&gt;
&lt;p&gt;rpm 的方式安装（推荐）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 下载JDK8
wget http://img.muzim.cn/openfile/jdk-8u191-linux-x64.rpm
# 安装
yum -y localinstall jdk-8u191-linux-x64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yum 的方式安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install -y java-1.8.0-openjdk-devel java-1.8.0-openjdk
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rabbitmq-安装docker&#34;&gt;rabbitmq 安装（docker）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 15672：控制台端口号 5672：应用访问端口号
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb-安装docker&#34;&gt;mongoDB 安装(docker)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#docker的方式安装mongo3.6版本，端口为27017
docker run --name mongo36 -p 27017:27017 -e $PWD/db:/data/db -d mongo:3.6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;activemq-安装docker&#34;&gt;activemq 安装(docker)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#docker的方式安装activemq，端口为61616
docker run -d --name myactivemq -p 61616:61616 -p 8161:8161 webcenter/activemq
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;postgres-安装docker&#34;&gt;postgres 安装(docker)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#postgres端口为5432，password密码需要自己修改
docker run --name postgres -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgres:9.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;erlang-安装&#34;&gt;erlang 安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#yum安装
yum -y install epel-release
yum install erlang -y
&lt;/code&gt;&lt;/pre&gt;
">常见开源组件的安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://blog.muzim.cn/post/about/"" data-c="
          &lt;p&gt;一个测试萌新起步&lt;br&gt;
记录工作中遇到的问题&lt;br&gt;
分享工作经验和各种工具使用经验&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>



<script src="/media/js/mouse/peace.js"></script>




</html>